% !TEX TS-program = pdflatexmk

% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
\usepackage[T1]{fontenc}

\usepackage{epsfig}
%\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}

\usepackage[scaled=0.8]{helvet}    % Less huge \textsf{functionName}
\usepackage[misc,geometry]{ifsym} % for letter symbol
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
%\usetikzlibrary{trees,snakes,arrows}
\usetikzlibrary{trees,arrows}
\usetikzlibrary{shapes,chains}
\usetikzlibrary{positioning}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}
\usepackage[nospace]{cite}


%\input{macros}
\usepackage{ifthen}
\newcommand{\mPoint}[1]{{\color{red}\textbf{Point: }#1}}
\newcommand{\mcneed}{\textbf{Citation needed}}
\newcommand{\mcfix}{\textbf{Fix citation}}

\definecolor{cbnavy}{RGB}{15, 32, 128}
\definecolor{cborange}{RGB}{245, 121, 58}
\definecolor{cbgreen}{RGB}{0, 150, 50}

%\newcommand{\runhead}[1]{\noindent\textbf{#1. }}
\newcommand{\runhead}[1]{\subsubsection{#1}}

% -- Fonts and styles for names
%\newcommand{\mItemStyle}[1]{\ensuremath{#1}}
%\newcommand{\mSetStyle}[1]{\ensuremath{\mathrm{\mathbf{#1}}}}
%\newcommand{\mFunStyle}[1]{\text{\textup{\textsf{#1}}}}
%\newcommand{\mConstStyle}[1]{\text{\textup{\textsf{#1}}}}
%\newcommand{\mVarStyle}[1]{\mathit{#1}}
%\newcommand{\mFactStyle}[1]{\text{\textsf{#1}}}
%\newcommand{\mMethodStyle}[1]{\mbox{\mConstStyle{#1}}}
%\newcommand{\mProtocolStyle}[1]{\mbox{\textrm{#1}}}

%\newcommand{\mItemStyle}[1]{\ensuremath{#1}}
%\newcommand{\mSetStyle}[1]{\ensuremath{\mathrm{\mathbf{#1}}}}
\newcommand{\mFunStyle}[1]{\textsf{#1}}
\newcommand{\mConstStyle}[1]{\textsf{#1}}
\newcommand{\mVarStyle}[1]{\mathit{#1}}
\newcommand{\mFactStyle}[1]{\textsf{#1}}
\newcommand{\mMethodStyle}[1]{\mConstStyle{#1}}
\newcommand{\mProtocolStyle}[1]{\text{#1}}



% -- Macros for consistent wording
\newcommand{\mSpec}{specification}  % The EDHOC spec document we are analyzing
\newcommand{\mDate}{2020-07-06}



% -- Formalization notation
\newcommand{\mRevLTK}{\ensuremath{\mathbf{A}_\mFunStyle{LTK}}}
\newcommand{\mTEE}{\ensuremath{\mathbf{A}_\mFunStyle{TEE}}}
\newcommand{\mRevEph}{\ensuremath{\mathbf{A}_\mFunStyle{Eph}}}
\newcommand{\mIStart}{\ensuremath{\mathbf{I}_\mFunStyle{S}}}
\newcommand{\mIComplete}{\ensuremath{\mathbf{I}_\mFunStyle{C}}}
\newcommand{\mRStart}{\ensuremath{\mathbf{R}_\mFunStyle{S}}}
\newcommand{\mRComplete}{\ensuremath{\mathbf{R}_\mFunStyle{C}}}
\newcommand{\mISend}{\ensuremath{\mathbf{I}_{\mFunStyle{SEND}}}}
\newcommand{\mRRecv}{\ensuremath{\mathbf{R}_{\mFunStyle{Recv}}}}

\newcommand{\mPredPcs}{\ensuremath{\mathbf{PCS}}}
\newcommand{\mPredInjI}{\ensuremath{\mathbf{InjAgree}_I}}
\newcommand{\mPredInjR}{\ensuremath{\mathbf{InjAgree}_R}}
\newcommand{\mPredImpI}{\ensuremath{\mathbf{ImpAgree}_I}}
\newcommand{\mPredImpR}{\ensuremath{\mathbf{ImpAgree}_R}}
\newcommand{\mSecADthree}{\ensuremath{\mathbf{{Sec}\mADthree}}}
\newcommand{\mIntADthree}{\ensuremath{\mathbf{Integ\mADthree}}}
\newcommand{\mK}{\ensuremath{\mathcal{K}}}
\DeclareMathOperator{\mLogicDot}{.}


% -- Domain specific macros
\newcommand{\mArxiv}{\texttt{arXiv}}
\newcommand{\mTamarin}{\mProtocolStyle{Tamarin}}
\newcommand{\mProverif}{\mProtocolStyle{ProVerif}}
\newcommand{\mEdhoc}{\mProtocolStyle{EDHOC}}
\newcommand{\mMuEdhoc}{\mProtocolStyle{\ensuremath{\mu}EDHOC}}
\newcommand{\mOscore}{\mProtocolStyle{OSCORE}}
\newcommand{\mSigma}{\mProtocolStyle{SIGMA}}
\newcommand{\mSigmaI}{\mProtocolStyle{SIGMA\nobreakdash-I}}
\newcommand{\mCbor}{\mProtocolStyle{CBOR}}
\newcommand{\mCose}{\mProtocolStyle{COSE}}
\newcommand{\mCoseEncrypt}{\mProtocolStyle{COSE\_Encrypt0}}
\newcommand{\mCoseSign}{\mProtocolStyle{Cose\_Sign1}}
\newcommand{\mHkdf}{\mProtocolStyle{HKDF}}
\newcommand{\mHkdfExtract}{\mProtocolStyle{HKDF\nobreakdash-extract}}
\newcommand{\mHkdfExpand}{\mProtocolStyle{HKDF\nobreakdash-expand}}
\newcommand{\mHmac}{\mProtocolStyle{HMAC}}
\newcommand{\mAead}{\mProtocolStyle{AEAD}}
\newcommand{\mAeadDecrypt}{\mProtocolStyle{AEAD\nobreakdash-decrypt}}
\newcommand{\mDecrypt}{\mProtocolStyle{decrypt}}
\newcommand{\mOptls}{\mProtocolStyle{OPTLS}}
\newcommand{\mNoise}{\mProtocolStyle{Noise}}
\newcommand{\mTls}{\mProtocolStyle{TLS}}
\newcommand{\mDandTls}{\mProtocolStyle{(D)TLS}}
\newcommand{\mCtls}{\mProtocolStyle{cTLS}}
\newcommand{\mCoap}{\mProtocolStyle{CoAP}}

\newcommand{\mStat}{\mMethodStyle{STAT}}
\newcommand{\mSig}{\mMethodStyle{SIG}}
\newcommand{\mPsk}{\mMethodStyle{PSK}}
\newcommand{\mStatStat}{\mMethodStyle{STAT-STAT}}
\newcommand{\mStatSig}{\mMethodStyle{STAT-SIG}}
\newcommand{\mSigStat}{\mMethodStyle{SIG-STAT}}
\newcommand{\mSigSig}{\mMethodStyle{SIG-SIG}}
\newcommand{\mPskPsk}{\mMethodStyle{PSK-PSK}}

\newcommand{\mSid}{\mConstStyle{sid}}    % session id = (u, v, s-key)

\newcommand{\mXor}{\mConstStyle{XOR}}
\newcommand{\mSuites}{\ensuremath{S_I}}
\newcommand{\mMethod}{\ensuremath{M}}
\newcommand{\mCi}{\ensuremath{C_I}}
\newcommand{\mCr}{\ensuremath{C_R}}
\newcommand{\mGu}{\ensuremath{Q_{s,U}}}
\newcommand{\mGi}{\ensuremath{Q_{s,I}}}
\newcommand{\mGr}{\ensuremath{Q_{s,R}}}
\newcommand{\mPriv}[1]{\ensuremath{d_{s,#1}}}
\newcommand{\mPub}[1]{\ensuremath{Q_{s,#1}}}
\newcommand{\mPrivE}[1]{\ensuremath{d_{e,#1}}}
\newcommand{\mPubE}[1]{\ensuremath{Q_{e,#1}}}
\newcommand{\mX}{\ensuremath{d_{e,I}}}
\newcommand{\mY}{\ensuremath{d_{e,R}}}
\newcommand{\mGiy}{\ensuremath{\mY\cdot\mGi}}
\newcommand{\mGrx}{\ensuremath{\mX\cdot\mGr}}
\newcommand{\mGx}{\ensuremath{Q_{e,I}}}
\newcommand{\mGy}{\ensuremath{Q_{e,R}}}
\newcommand{\mGxy}{\ensuremath{P_e}}
\newcommand{\mSessKey}{\ensuremath{Z}}
\newcommand{\mIDPsk}{\mConstStyle{ID\_PSK}}
\newcommand{\mSign}[1]{\ensuremath{\mathit{sign_{#1}}}}
\newcommand{\mVf}[1]{\ensuremath{\mathit{vf_{#1}}}}
\newcommand{\mDH}{\ensuremath{\mathit{dh}}}
\newcommand{\mTH}{\ensuremath{\mathit{th}}}
\newcommand{\mTHtwo}{\ensuremath{\mathit{th}_2}}
\newcommand{\mKtwoe}{\ensuremath{K_\mathit{2e}}}
\newcommand{\mKtwom}{\ensuremath{K_\mathit{2m}}}
\newcommand{\mKtwoae}{\ensuremath{K_\mathit{2ae}}}
\newcommand{\mTID}{\ensuremath{\mathit{tid}}}

\newcommand{\mKthreeae}{\ensuremath{K_\mathit{3ae}}}
\newcommand{\mKthreem}{\ensuremath{K_\mathit{3m}}}

\newcommand{\mTHthree}{\ensuremath{\mathit{th}_3}}
\newcommand{\mhplain}{\ensuremath{h''}}
\newcommand{\mCredi}{\ensuremath{Q_{s,I}}}
\newcommand{\mCredr}{\ensuremath{Q_{s,R}}}
\newcommand{\mHash}{\ensuremath{h}}

\newcommand{\mTHfour}{\ensuremath{\mathit{th}_4}}
\newcommand{\mAuthi}{\ensuremath{\mathit{Auth}_I}}
\newcommand{\mAuthr}{\ensuremath{\mathit{Auth}_R}}

\newcommand{\mMactwo}{\ensuremath{\mathit{MAC}_2}}
\newcommand{\mMacthree}{\ensuremath{\mathit{MAC}_3}}

\newcommand{\mSigtwo}{\ensuremath{\mathit{Sig}_2}}
\newcommand{\mSigthree}{\ensuremath{\mathit{Sig}_3}}

% \newcommand{\mMsgone}{\mConstStyle{m1}}
% \newcommand{\mMsgtwo}{\mConstStyle{m2}}
% \newcommand{\mMsgthree}{\mConstStyle{m3}}
\newcommand{\mMsgone}{\ensuremath{m_1}}
\newcommand{\mMsgtwo}{\ensuremath{m_2}}
\newcommand{\mMsgthree}{\ensuremath{m_3}}

\newcommand{\mCipher}{\mConstStyle{CIPHERTEXT\_2}}

\newcommand{\mAD}{\ensuremath{\mathit{ad}}}
\newcommand{\mADone}{\ensuremath{\mathit{ad}_1}}
\newcommand{\mADtwo}{\ensuremath{\mathit{ad}_2}}
\newcommand{\mADthree}{\ensuremath{\mathit{ad}_3}}

\newcommand{\mPRK}{\ensuremath{\mathit{PRK}}}
\newcommand{\mPRKtwo}{\ensuremath{\mPRK_\mathit{2e}}}
\newcommand{\mPRKthree}{\ensuremath{\mPRK_\mathit{3e2m}}}
\newcommand{\mPRKfour}{\ensuremath{\mPRK_\mathit{4x3m}}}

\newcommand{\mIdcredi}{\ensuremath{ID_I}}
\newcommand{\mIdcredr}{\ensuremath{ID_R}}
\newcommand{\mLtki}{\mConstStyle{ltk\_I}}
\newcommand{\mLtkr}{\mConstStyle{ltk\_R}}
\newcommand{\mLtk}{\mConstStyle{ltk}}

\newcommand{\cm}{\checkmark}

% TIKZ messages and actions
\newcommand{\msg}[4]{\draw[->,thick] ([yshift=-#1]#2.south) coordinate (l1)--(l1-|#3) node[midway, above]{#4}}
\newcommand{\action}[3]{\node[draw,thick,fill=white,align=center,below={#1} of {#2}]{#3}}

% Tamarin symbols
\newcommand{\ifarrow}[1][]{\ifthenelse{\equal{#1}{}}{\rightarrow}{-\hspace{-4.22pt}[{#1}]\hspace{-5.6pt}\rightarrow}}
\newcommand{\semarrow}[1][]{\ifthenelse{\equal{#1}{}}{\Rightarrow}{=\hspace{-3.0pt}[{#1}]\hspace{-3pt}\Rightarrow}}
\newcommand{\mIn}{\mathsf{In}}
\newcommand{\mOut}{\mathsf{Out}}
\newcommand{\mFr}{\mathsf{Fr}}
\newcommand{\mKD}{\mathsf{KD}}
\newcommand{\mKU}{\mathsf{KU}}
\newcommand{\mT}[1]{\text{\texttt{#1}}}



\begin{document}
\title{Extended Formal Analysis of the EDHOC Protocol in Tamarin}
\author{
    Karl Norrman\inst{1,2}\orcidID{0000-0003-0164-1478} \and
    Vaishnavi Sundararajan\inst{3}\orcidID{0000-0002-5945-5208} \and
    Alessandro Bruni\inst{4}
}
\authorrunning{Norrman, Sundararajan and Bruni}
\institute{
    KTH Royal Institute of Technology, Stockholm, Sweden \and
    Ericsson Research, Security, Stockholm, Sweden\\
    \email{karl.norrman@ericsson.com} \and
    University of California, Santa Cruz, USA\\
    \email{vasundar@ucsc.edu} \and
    IT University of Copenhagen, Copenhagen, Denmark\\
    \email{brun@itu.dk}
}

\maketitle
%

\begin{abstract}
Given how common IoT devices that use constrained resources are becoming
today, the need of the hour is communication protocols which can operate
securely under such limitations.
%
For a few years, the Internet Engineering Task Force (IETF) has been working
to standardize \mEdhoc{}, an authenticated key establishment protocol for
such constrained IoT devices.
%
The first version of \mEdhoc{} was proposed in 2016.
%
In 2018, Bruni et al.~\cite{DBLP:conf/secsr/BruniJPS18} used the \mProverif{}
tool~\cite{DBLP:conf/csfw/Blanchet01} to formally analyze an early version of
\mEdhoc{}, which had only two key establishment methods.
%
By 2021, the protocol had been fleshed out much more, with multiple new key
establishment methods, and this version was formally analyzed using the
\mTamarin{} prover~\cite{DBLP:conf/cav/MeierSCB13} in~\cite{Norr21}.
%
In this paper, we build on that work, by modifying the model, analyzing some new properties, and discussing some aspects of the latest \mEdhoc{}
specification. In particular, we extend the modeling in~\cite{Norr21} with trusted execution environments (TEEs), modify the way we model \mXor{} encryption, and in addition to the properties verified in~\cite{Norr21}, we verify weak post-compromise security (PCS) as well as the secrecy and integrity of some additional data used as part of the protocol.

\keywords{Formal Verification, Symbolic Dolev-Yao Model,
           Authenticated Key Establishment, Protocols, IoT, Tamarin.}

\end{abstract}
%
%-------------------------------------------------------------------------- sec
\section{\uppercase{Introduction}}
\label{sec:introduction}
IoT protocols are often run on devices which operate under severe restrictions
on resources like bandwidth and energy consumption.
%
These constrained devices are often simple in their operation, but need to
communicate and function without human interference or maintenance for
extended periods of time.
%
The Internet Engineering Task Force (IETF) is standardizing new protocols to secure communications between devices that operate under such restrictions.
%
One such is the Object Security for Constrained RESTful Environments
(\mOscore{}) protocol.
%
However, \mOscore{} requires the pre-establishment of a security context.
%
To this end, a key exchange protocol named Ephemeral Diffie-Hellman Over
COSE
(\mEdhoc{}) is being discussed in the IETF.
%
Since \mEdhoc{} will establish security contexts for \mOscore{}, the same
resource constraints (especially those pertaining to message size) apply to the
former as for the latter.
%
While establishing security contexts for \mOscore{} is the primary goal for the
\mEdhoc{} protocol, there might well be other use cases which have not been
explored in depth yet.
%
It is therefore important to ensure that fundamental properties
expected of key exchange protocols as established in the literature are satisfied
by \mEdhoc{} as well.
%

%-------------------------------------------------------------------------- sub
\subsection{Evolution of \mEdhoc}
\label{sec:edhocevol}
The first \mEdhoc{} framework was introduced in March 2016.
%
It allowed two different key establishment methods -- one involved a pre-shared
Diffie-Hellman (DH) \emph{cryptographic core}, and the other was a
variation on challenge-response signatures, {\`a} la
\mOptls{}~\cite{DBLP:conf/eurosp/KrawczykW16}.

%
A \emph{cryptographic core}, often just called a core, is an academic protocol,
i.e., with no encodings or application-specific details as needed for an
industrial protocol.
%
Once these ingredients are added to a cryptographic core, we obtain a
key-establishment method.
%
Since then, the protocol has seen multiple changes.
%
In May 2018, the designers replaced the challenge-response signature core with
one based on \mSigma{}
(SIGn-and-MAc)~\cite{sigma,bruni-analysis-selander-ace-cose-ecdhe-08}, and
in
2020, three new cores, which mixed challenge-response signatures and regular
signatures were added as well~\cite{our-analysis-selander-lake-edhoc-00}.
%
While this is the version we base our formal analysis on, there have been later versions. 
%
See Section~\ref{sec:newdrafts} for a more detailed discussion.

%-------------------------------------------------------------------------- sub
\subsection{Related Work and Contributions}
\label{sub:related}
The earliest related work is~\cite{DBLP:conf/secsr/BruniJPS18}, which formally
analyzes the May 2018 version of \mEdhoc{} using the \mProverif{}
tool~\cite{DBLP:conf/csfw/Blanchet01}.
%
In this paper, the authors analyze two key establishment methods -- one built
on
a pre-shared key authentication core, and one based on \mSigma{}.
%
The authors check  the following properties: secrecy, identity protection, strong authentication, perfect forward secrecy
(PFS), and integrity of application data.
%
Later work~\cite{Norr21} analyzes the July 2020 version of \mEdhoc{} in the
\mTamarin{} prover~\cite{DBLP:conf/cav/MeierSCB13}.
%
This version of the protocol has four key establishment methods.
%
In~\cite{Norr21}, the properties checked for are injective agreement, implicit
agreement, and perfect forward secrecy for the session key material.
%
That work also includes a discussion about the various design choices made as
part of \mEdhoc{}, and the impact of \mEdhoc{} in multiple use-case scenarios.
%%

%-------------------------------------------------------------------------- sub
\subsection{Contributions}
\label{sec:contributions}
In this paper, we extend the work presented in~\cite{Norr21}.
%
We formally analyze the \mEdhoc{} specification as of July
2020~\cite{our-analysis-selander-lake-edhoc-00}, but our formal analysis applies as far as the version of the \mSpec{} from February 2021.
%
We extend the adversary model and \mTamarin{} system models to capture weak
post-compromise security (PCS) and model Trusted Execution Environments
(TEE).
%
We also alter the formal modeling used for encryption under \mXor{}.
%
We formally verify the following properties:
\begin{itemize}
\item Injective agreement
\item Implicit agreement
\item Perfect Forward Secrecy (PFS) for the session-key material
\item Weak post-compromise security for the session-key material
\item Secrecy and integrity of \mADthree
\end{itemize}
%
We follow the definition of weak PCS by~\cite{DBLP:conf/csfw/Cohn-GordonCG16},
which subsumes PFS.
%
Since \mEdhoc{} is still a protocol under development, the latest version of \mEdhoc{} is the one from July 2022~\cite{draft-ietf-lake-edhoc-15}, which contains details which are not covered by our formal model.
%
We do, however, refer to various aspects
(error handling, denial of service etc) of the July 2022 version of the \mSpec{}, namely 
in Sections~\ref{sec:errorHandling} and \ref{sec:discussion}.
%
We also discuss various issues arising due to the use of trusted
execution environments (TEEs), denial of service (DoS) attacks, error handling,
the negotiation of parameters (which the formal model abstracts
away) for establishing the protocol, and other potential attacks and concerns.
%
We have communicated these issues to the developers of the protocol.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{The \mEdhoc{} Protocol}}
\label{sec:edhoc}
% !TEX root = paper.tex
In this section, we describe the various key establishment methods of the
\mEdhoc{} protocol.
%
Following~\cite{Norr21}, we refer to the two roles executing the protocol as
the initiator $I$ and the responder $R$.
%
We annotate values with $I$ and $R$ to make explicit which role they belong
to.
%

%------------------------------------------------------------------------- sub
\subsection{Notation}
\label{sec:notation}
We denote by $\langle d_{t, \mathit{id}}, Q_{t, \mathit{id}}\rangle$
public-private key pairs, where $d$ is the private key, $Q$ is the public key,
$t \in \{e, s\}$ indicates whether the key is ephemeral or static,
and $\mathit{id}$ indicates the party to whom the key pair belongs.
%
When clear from context, we will often drop some (or all) of the subscripts.
%
Static key pairs (suitable for regular or challenge-response signatures)
are long-term authentication credentials, whereas ephemeral key pairs are
those generated afresh for each execution of the protocol.
%

Parties can authenticate using regular signatures or challenge-response
signatures.
%
In the former case, we say that they use the
\emph{signature-based authentication method} (\mSig{}).
%
In the latter case, we say, following the terminology in the \mSpec{},
that they use the \emph{static key authentication method} (\mStat{}).
%
We adopt the challenge-response terminology
from~\cite{DBLP:conf/crypto/Krawczyk05}.
%

\mEdhoc{} fundamentally uses elliptic curves and associated Diffie-Hellman
operations.
%
Signatures using a party $A$'s keys are denoted by \mSign{A}$(\cdot)$, while
the verification thereof is denoted by \mVf{A}$(\cdot)$.
%
A Diffie-Hellman operation which combines a private key $d$ and a point $P$
on the elliptic curve is represented as $\mDH(d, P)$.
%
We will often overload notation to let $P$ stand for both the point on the
elliptic curve as well as the corresponding bitstring encoding.

%------------------------------------------------------------------------- sub
\subsection{Overall Description}
\label{sec:description}
\mEdhoc{} is designed to establish a security context for the \mOscore{} protocol.
%
This context, in particular, includes the session-key material (we denote this by
\mSessKey{}).
%
The generalized abstract protocol as given in the \mSpec{}~\cite{our-analysis-selander-lake-edhoc-00} consists of three
messages, and is shown in Figure~\ref{fig:edhocFramework}.
%
The abstract structure is the same across methods.
%
However, the authentication mechanisms and key derivation procedures differ between
methods.
%
\mEdhoc{} may also transfer application data \mADone{}, \mADtwo{}, and \mADthree{} in
addition to establishing the \mOscore{} security context.
%

%
\begin{figure}[ht]
\centering
\tikzset{>=latex, every msg/.style={draw=thick}, every
node/.style={fill=none,text=black}}
\begin{tikzpicture}
    \node (ini) at (0, 0) {Initiator};
    \draw [very thick] (0, -0.25) -- (0,-2.3);
    \draw [very thick] (5.75, -0.25) -- (5.75,-2.3);
    \node (res) at (5.75,0) {Responder};
    \msg{1em}{ini}{res}{\mMsgone: \mMethod, \mSuites, \mGx, \mCi,
\mADone};
    \msg{3em}{res}{ini}{\mMsgtwo: \mCi, \mGy, \mCr, \{\mIdcredr, \mAuthr,
\mADtwo\}};
    \msg{5em}{ini}{res}{\mMsgthree: \mCr, \{\mIdcredi, \mAuthi, \mADthree\}};
    \draw [line width=1mm] (-0.75,-2.3) -- (0.75,-2.3);
    \draw [line width=1mm] (5.75-0.75,-2.3) -- (5.75+0.75,-2.3);
    \node (padding) at (0,-2.5) {};
    \end{tikzpicture}
    \caption{Structure of \mEdhoc{}: $\{t\}$ means $t$ is encrypted and integrity
protected.~\cite{Norr21}}
\label{fig:edhocFramework}
\end{figure}
%
Of the three messages \mMsgone, \mMsgtwo, and \mMsgthree, the first two, among other things, establish a
common authentication method \mMethod{} and ciphersuite \mSuites{}.
%
The party playing the initiator role uses \mMethod{} to propose which
authentication methods the two parties shall use, and in \mSuites{}, proposes an ordered list
of choices for the ciphersuite.
%
The chosen authentication methods may differ for the two roles,
yielding four possible
combinations: \mSigSig{}, \mSigStat{}, \mStatSig{}, and \mStatStat{},
where the first authentication method in each combination is used by the
initiator, and the second by the responder.
\footnote{As in the \mSpec{}, we will from now on overload
notation and refer to the combinations of authentication methods as methods
as
well.}
%
The party executing the responder role may choose to reject the method and/or
ciphersuite chosen by the initiator by sending an error message.
%
This results in abandoning this session and renegotiating, as the initiator
goes down their list of choices for ciphersuites, and picks the next option for
a next execution of the protocol.
%
Our analysis does not cover such renegotiation which requires maintaining
state
between executions to remember the rejected ciphersuites.
%
However, we will discuss the ramifications of such a renegotiation procedure
and the error messages later, in Section~\ref{sec:errorHandling}.
%

In addition to negotiating the method and ciphersuite, the first two messages are
also instrumental for the exchange of public ephemeral keys \mGx{} and
\mGy{},
and connection identifiers \mCi{} and \mCr{}, for the initiator and responder
roles respectively.
%
The \mSpec{} states that the connection identifiers serve only to route
messages
to the correct party executing \mEdhoc{}, but also claims that they may be
used in turn by protocols (like \mOscore{}) which use the security context
established by \mEdhoc{}.
%
While the \mSpec{} does not require any explicit security guarantees to be
satisfied by these connection identifiers, it does, however, require that the
identifiers be unique, i.e., in any session, $\mCi{} \neq \mCr{}$, and that the
parties involved in the session can verify this uniqueness.
%
More precisely, the \mSpec{} states that \mOscore{} should be able to use these
identifiers to retrieve any particular security context.
%
In this work, as in~\cite{Norr21}, we verify that the parties agree on the
values of \mCi{} and \mCr{}.
%
The second and third messages also serve to identify and authenticate each
party to the other.
%
These messages contain long-term key identifiers (\mIdcredi{} and
\mIdcredr{}).
%
Additionally, the messages contain authenticating information
(\mAuthi{} and \mAuthr{}), which lets each
party know that the other party does indeed control the long-term key
associated with these identifiers.
%
The authentication information is structured differently for each authentication method.
%

Consider the following scenario.
%
The initiator $I$ chooses the method $\mSigStat{}$, and sends this via
$\mMethod{}$ to the responder $R$.
%
$R$ now has the option to reject this choice of method.
%
However, if $R$ chooses to accept this method, they need to provide an
identifier \mIdcredr{} for a key pair which can be used with
challenge-response
signatures
as well as authenticating information \mAuthr{}, as dictated by
the static key authentication method \mStat{}.
%
$I$ will then respond with an identifier \mIdcredi{} corresponding to a key
pair, which is suitable for regular signatures, and provide authentication
\mAuthi{} as appropriate for the signature-based method \mSig{}.

%-------------------------------------------------------------------------- sub
\subsection{Key Schedule}
\label{sec:keysched}
The second and third messages of \mEdhoc{} contain
authenticating information.
%
This information is either a signature or a message authentication code (MAC),
as we will describe in more detail in Section~\ref{sec:edhocauth}.
%
The keys for these are generated using a key schedule which is intrinsic to the functioning of \mEdhoc{}.
%
The key schedule takes a DH key \mGxy{} as basic input and builds upon it, as shown in Figure~\ref{fig:kdfdiagram}.
%
\begin{figure}[!h]
\scalebox{.785}{
\begin{tikzpicture}[%
    >=latex,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=4mm and 60mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
\tikzset{
terminput/.style={rounded corners},
term/.style={rounded corners},
  base/.style={draw, thick, on chain, on grid, align=center, minimum height=4ex},
  dhkbox/.style={draw=cbgreen, fill=cbgreen!25, rectangle},
  dhk/.style={base, dhkbox},
  prkbox/.style={draw=cborange, fill=cborange!25, rectangle},
  prk/.style={base, prkbox},
  hkdfext/.style={base, draw=black, fill=none, rectangle},
  hkdfexp/.style={base, draw=black, fill=none, rectangle},
  keybbox/.style={draw=cbnavy, fill=cbnavy!25, rectangle},
  keyb/.style={base, keybbox, text width=4em},
  norm/.style={->, draw, black},
  cond/.style={base, draw=black, dashed, fill=none, rectangle},
  txt/.style={base, draw=none, fill=none}
  }
\node [prk, join] (p2) {\mPRKtwo};
\node [cond, join] (c1) {R uses \mStat?};

\node [prk, below=6mm of c1.south] (p3) {\mPRKthree};
\draw [->, norm] (c1.south) -- (p3.north) node[midway, right] {N};

\node [cond, join, below=10mm of p3.south] (c2) {I uses \mStat?};
\node [prk, below=8mm of c2.south] (p4) {\mPRKfour};
\draw [->, norm] (c2.south) -- (p4.north) node[midway, right] {N};

\node [hkdfext, right=3cm of p3] (h3) {\mHkdfExtract};
\node [hkdfext, right=3cm of p4] (h5) {\mHkdfExtract};

\node [hkdfexp, shape border rotate=180, left= 2.5cm of p4] (h6) {\mHkdfExpand};
\node [keyb, join, left=3cm of h6] (k3) {\mKthreem};
\node [hkdfexp, shape border rotate=180, below= 0.8cm of h6] (h9) {\mHkdfExpand};
\node [txt, join, left=1cm of h9.west] (t4) {EDHOC-Exporter};

\node [hkdfexp, shape border rotate=180, left= 2.5cm of p3] (h4) {\mHkdfExpand};
\node [keyb, join, left=3cm of h4] (k2) {\mKtwom};

\node [hkdfexp, shape border rotate=180, left= 2.5cm of p2] (h2) {\mHkdfExpand};
\node [keyb, join, left=3cm of h2] (k1) {\mKtwoe};

\node [hkdfexp, shape border rotate=180, below= 0.8cm of h4] (h8) {\mHkdfExpand};
\node [keyb, below=0.8cm of k2] (k2b) {\mKthreeae};

\node [txt, left=1cm of k1.west] (t1) {Enc (XOR) \\ in m2};
\node [txt, left=1cm of k2.west] (t2) {\mMactwo~(signed if \\ R uses \mSig)};
\node [txt, left=1cm of k2b.west] (t2b) {\mAead\ in m3};
\node [txt, left=1cm of k3.west] (t3) {\mMacthree~(signed if \\ I uses \mSig)};

\draw [->, norm] (k1.west) -- (t1.east);
\draw [->, norm] (k2.west) -- (t2.east);
\draw [->, norm] (k2b.west) -- (t2b.east);
\draw [->, norm] (k3.west) -- (t3.east);

\draw [->, norm] (p3.south) ++(0,-0.5) -- (h8);
\draw [->, norm] (h8) -- (k2b);
\draw [->, norm] (p2) -- (h2); 
\draw [->, norm] (c1.east) -- ++(2.025,0) -- (h3.north) node[midway,above left] {Y};
\draw [->, norm] (h3.west) -- (p3.east);
\draw [->, norm] (p3) -- (h4); 
\draw [->, norm] (c2.east) -- ++(2.07,0) -- (h5.north) node[midway,above left] {Y};
\draw [->, norm] (h5.west) -- (p4.east);
\draw [->, norm] (p4) -- (h6);
\draw [->, norm] (p4.west) ++(-0.25,-0) -- ++(0,-0.8) -- (h9.east);

\node [hkdfext, right=3cm of p2] (h1) {\mHkdfExtract};
\node [dhk, right=2.7cm of h1] (p0) {$\mGxy$};
\node [terminput, text width=2em, below = 0.2cm of p0] (u1) {Salt};
\draw [->] (h1.west) -- (p2.east);
\draw [->] (u1.west) -- ++(-2.27,0) -- (h1.south);
\draw [->] (p0.west) -- (h1.east);


\node [dhk, right = 2.7cm of h3] (u2) {$P_R$};
\draw [->, norm] (u2.west) -- (h3.east);

\node [dhk, right = 2.7cm of h5] (u3) {$P_I$};
\draw [->, norm] (u3.west) -- (h5.east);


\node [term, above = 0.55cm of h4] (u5) {\mTHtwo};
\draw [->, dotted, shorten >=1mm] (u5) -- (h4);
\draw [->, dotted, shorten >=1mm] (u5) -- (h2);

\node [term, above = 0.5cm of h6] (u6) {\mTHthree};
\draw [->, dotted, shorten >=1mm] (u6) -- (h6);
\draw [->, dotted, shorten >=1mm] (u6) -- (h8);

\node [term, below=0.4cm of p4] (u7) {\mTHfour};
\draw [-> , dotted ] (u7.west) -- ([yshift=-0.4em] h9.east);
\end{tikzpicture}
}
\caption{Key schedule for~\cite{our-analysis-selander-lake-edhoc-00}: $P_e, P_I, P_R$ are the DH keys, \mPRKtwo,
\mPRKthree, \mPRKfour{} are the intermediate key material, and
\mKtwoe,\mKtwom,
\mKthreeae, \mKthreem{} are the encryption keys for \mAead{} or
\mXor{}. Dashed boxes are conditionals.~\cite{Norr21}}
\label{fig:kdfdiagram}
\end{figure}
%

To derive keys, \mEdhoc{} uses two functions from the \mHkdf{}
interface~\cite{rfc5869}, \mHkdfExtract{} and \mHkdfExpand{}.
%
Both functions take as argument two values -- an input and a salt.
%
For \mHkdfExtract{}, the input is a DH key, while for \mHkdfExpand{},
it is intermediate key material.
%

As mentioned earlier, the fundamental building block for the key schedule is
the ephemeral DH key \mGxy{}, which is computed in two different ways by
$I$ (as $\mDH(\mX, \mGy)$) and $R$ (as $\mDH(\mY, \mGx)$).
%
This key gives rise to intermediate keys \mPRKtwo{}, \mPRKthree{} and
\mPRKfour{}, which can be derived as part of protocol execution.
%
Each intermediate key gives rise to encryption and integrity keys
(\mKtwoe, \mKtwom{}, \mKthreeae, and \mKthreem)
corresponding to each message in the protocol.
%

In order to generate the final keys, the two \mHkdf{} algorithms use various
values for salt.
%
\mPRKtwo{} is generated by the \mHkdfExtract{} algorithm while using the
empty
string as the salt.
%
\mPRKthree{} and \mPRKfour{} are separately generated if $R$ or $I$ uses the
\mStat{} method, using the corresponding DH key as input and the previous
intermediate key as salt.
%
The key $P_{R}$, which is computed as $\mDH(\mX,\ \mGr{}) = \mDH(\mPriv{R},\
\mGx)$, is used if the responder uses the \mStat{} authentication
method.
%
Similarly, the key $P_{I}$ is used if the initiator uses \mStat{}, and is
computed as $\mDH(\mY,\ \mGi{}) = \mDH(\mPriv{I},\ \mGy)$.
%

These intermediate keys are fed into \mHkdfExpand{}, which uses as salt a value $\textit{th}$, which is a running
hash of the information transmitted thus far as part of the protocol.
%
By $\textit{th}_{i}$, we denote the hash corresponding to the $i^{\rm{th}}$ message.
%

At the end of a successful run of the protocol, the session-key material is
established as \mSessKey{}, which we define as a set of various keys.
%
This set always includes \mGxy{}, and if the initiator (resp. the responder) uses
the \mStat{} authentication method, then it also includes $P_{I}$ (resp.
$P_{R}$).
%
We
discuss which material should be included in \mSessKey{} in more detail
in Section~\ref{sec:formalization}, and the consequences of
various choices in Section~\ref{sec:sessionKeyMaterial}.
%
Once \mSessKey{} has been established, an \mHkdf{}-based key exporter
named
\mEdhoc-Exporter extracts the keys required by the security protocol.
%

%-------------------------------------------------------------------------- sub
\subsection{About Authentication in \mEdhoc{}}
\label{sec:edhocauth}
We now describe how the authentication information is constructed,
depending on whether the \mSig{} or \mStat{} method is used.
%
For both methods, the following information is used to compute
\mAuthr{}: \mIdcredr{}, \mCredr{}, a transcript hash of all the communicated
information thus far in the protocol, and \mADtwo{}, if included.
%
\mAuthi{} uses the same pieces of information, but corresponding to the
initiator role.
%
A MAC is obtained by feeding this material as additional data and the empty
string as input to the Authenticated Encryption with Additional Data (AEAD) algorithm as indicated in the established ciphersuite \mSuites{}.
%
The encryption key for the AEAD algorithm is constructed, for both roles,
using the ephemeral key material \mGx{}, \mGy{}, \mX{}, and \mY{}.
%
The initiator computes $\mDH(\mX, \mGy)$ while the responder computes
$\mDH(\mY, \mGx)$, and DH operations give rise to the same key under both
these computations.
%

When $I$ uses the \mSig{} authentication method, \mAuthi{} is $I$'s signature
over the MAC computed as above, along with the data covered by the MAC.
%
However, when $I$ uses the \mStat{} method, \mAuthi{} is just the MAC, with
one difference: the MAC key is derived using both the ephemeral key material
\mGxy{} as well as the long-term key for the initiator
$\langle\mPriv{I},\ \mPub{I}\rangle$.
%
This is similar to the 1-RTT semi-static pattern in \mOptls{} which computes the
MAC key \textsf{sfk} for the message
\textsf{sfin}~\cite{DBLP:conf/eurosp/KrawczykW16}.
%
The same procedures works for $R$ as well (with the values corresponding to
$R$).
%
The abstract calculation for the authentication information values is as shown
in Table~\ref{tab:authvalues}~\cite{Norr21}.
%
We use $\mathit{MAC}_{R}$ (resp. $\mathit{MAC}_{I}$) to denote a MAC
which uses
an encryption key constructed using
$\langle\mPriv{R},\ \mPub{R}\rangle$ and $\langle\mX,\ \mGx\rangle$
(resp. using $\langle\mPriv{I},\ \mPub{I}\rangle$ and $\langle\mY,\
\mGy\rangle$).
%
\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|}
        \hline
        \mMethod & \mAuthi & \mAuthr\\
        \hline
        \mSigSig{} & $\mSign{I}(\cdot)$ & $\mSign{R}(\cdot)$ \\
        \mSigStat{} & $\mSign{I}(\cdot)$ & $\textit{MAC}_R(\cdot)$\\
        \mStatSig{} & $\textit{MAC}_I(\cdot)$ & $\mSign{R}(\cdot)$\\
        \mStatStat{} & $\textit{MAC}_I(\cdot)$ & $\textit{MAC}_R(\cdot)$\\
        \hline
\end{tabular}
\caption{The outer functions for each method \mMethod{}~\cite{Norr21}}
\label{tab:authvalues}
\end{table}
%

In addition to this, the second and third messages have
provisions for transferring application messages which are encrypted and
integrity protected, as can be seen in~\ref{fig:edhocFramework}.
%
The second message is encrypted by performing a bit-wise \mXor{} between
the plaintext and the output of the key derivation function \mHkdf{}, as
in Section~\ref{sec:keysched}.
%
For the third message, encryption and integrity protection is assured by the
\mAead{} algorithm.
%

In Figure~\ref{fig:edhocsigstat} we show an example of protocol execution
under
the \mSigStat{} method.
%
The figure describes in detail the various message patterns, operations and
key derivations used to construct these messages.
%
\begin{figure}[ht]
\centering
\scalebox{.7}{
\tikzset{>=latex, every msg/.style={draw=thick}, every
node/.style={fill=none,text=black}}
\begin{tikzpicture}
    \node (ini) at (0, 0) {Initiator};
    \draw [very thick] (0, -0.5) -- (0,-14.8);
    \draw [very thick] (9, -0.5) -- (9,-14.8);
    \node[below=0.5em of ini,fill=white] {$
    \begin{array}{c}
        \text{Knows}\ \langle\mPriv{I},\ \mPub{I}\rangle,\ \mIdcredi,\ \mIdcredr,\
\mADone,\ \mADthree
    \end{array}
    $};
    \node (res) at (9,0) {Responder};
    \node[below=0.5em of res,fill=white] {$
    \begin{array}{c}
        \text{Knows}\ \langle\mPriv{R},\ \mPub{R}\rangle, \ \mIdcredr,\ \mADtwo
    \end{array}$};
    \action{3.7em}{ini}{Generates $\mMethod,\ \mSuites,\ \mCi,\ \langle\mX{},\
\mGx\rangle$};
    \msg{7em}{ini}{res}{\mMsgone: \mMethod, \mSuites, \mGx, \mCi,
\mADone};
    \action{8em}{res}{$
      \begin{array}{c}
          \text{Generates } \mCr,\ \langle\mY{},\ \mGy\rangle\\
          \ \ P_e = \mDH(\mY,\ \mGx{})\\
          \ \ P_R = \mDH(\mPriv{R},\ \mGx{})\\
        \mTHtwo = \mHash(\mMsgone, \langle \mCi, \mGy, \mCr \rangle)\\
        \mPRKtwo = \mHkdfExtract(\textrm{``\phantom{}''}, P_e) \\
        \mPRKthree = \mHkdfExtract(\mPRKtwo, P_R) \\
        \mKtwom = \mHkdfExpand(\mPRKthree, \mTHtwo) \\
        \mMactwo = \mAead(\mKtwom; \langle \mIdcredr, \mTHtwo, \mCredr,
\mADtwo \rangle; \textrm{``\phantom{}''}) \\
        \mKtwoe = \mHkdfExpand(\mPRKtwo, \mTHtwo)
      \end{array}$};
    \msg{24em}{res}{ini}{\mMsgtwo: \mCi, \mGy, \mCr, $\overbrace{\mKtwoe\
\mXor\ \langle \mIdcredr, \mMactwo, \mADtwo \rangle}^{\mCipher}$};
    \action{25em}{ini}{$
      \begin{array}{c}
        %\mTHtwo = \mHash(\mMsgone, \langle \mCi, \mGy, \mCr \rangle) \
        \ P_e = \mDH(\mX,\ \mGy{})\\
        \mPRKtwo = \mHkdfExtract(\textrm{``\phantom{}''}, P_e) \\
        %\mKtwoe = \mHkdfExpand(\mPRKtwo,\mTHtwo)\\
        %\mGrx = \mCredr^{x} \\
        \ \ P_R = \mDH(\mX,\ \mPub{R})\\
        \mPRKfour = \mPRKthree = \mHkdfExtract(\mPRKtwo, P_R) \\
        %\mKtwom = \mHkdfExpand(\mPRKthree, \mTHtwo) \\
        \mKthreeae = \mHkdfExpand(\mPRKthree, \mTHtwo) \\
        \mTHthree = \mHash(\mTHtwo, \mCipher, \mCr)\\
        \mKthreem = \mHkdfExpand(\mPRKfour, \mTHthree) \\
        \mMacthree = \mAead(\mKthreem; \langle \mIdcredi, \mTHthree,
\mCredi, \mADthree \rangle; \textrm{``\phantom{}''}) \\
        \mSigthree = \mSign{I}(\langle \langle \mIdcredi, \mTHthree, \mCredi,
\mADthree \rangle, \mMacthree \rangle)
      \end{array}$};
    \msg{38.5em}{ini}{res}{$\mMsgthree: \mCr, \mAead(\mKthreeae;
\mTHthree; \langle \mIdcredi, \mSigthree, \mADthree \rangle$)};
    \action{40em}{res}{$
    \begin{array}{c}
        \mTHthree = \mHash(\mTHtwo, \mCipher, \mCr)\\
        \mKthreem = \mHkdfExpand(\mPRKthree, \mTHthree) \\
        \mKthreeae = \mHkdfExpand(\mPRKthree, \mTHthree)
    \end{array}$};
    \draw [line width=1mm] (-2,-14.8) -- (2,-14.8);
    \draw [line width=1mm] (7,-14.8) -- (11,-14.8);
    \end{tikzpicture}
}
    \caption{The \mSigStat{} method for \mEdhoc{}. $\langle\cdot\rangle$
denotes a tuple, and the hash function \mHash{} is as established in the
ciphersuite \mSuites{}.~\cite{Norr21}}
\label{fig:edhocsigstat}
\end{figure}

%------------------------------------------------------------------------- sec
\section{Implementation Aspects and Key Protection}
\label{sec:TEE}
Authentication of a specific IoT device assumes that the device is the only
entity with access to the long-term key associated with its
identity.
%
Since IoT devices may be accessible to adversaries, e.g., an insider cloning a
key card, long-term keys must be appropriately protected.
%
A state-of-the-art approach is to use a trusted execution environment (TEE),
which holds the key and provides an API for operations using the key.
%
This is the approach taken by the
TrustZone-based \mMuEdhoc{}~\cite{DBLP:conf/codaspy/Hristozov0XFLS21}
implementation, for example.
%
Typical operations include signatures using the long-term private key of a
party.
%

TEEs can be of differing complexity.
%
Some, like ARM TrustZone and Intel SGX, are general-purpose execution
environments, which can be programmed in many different ways.
%
Others, like the Universal Subscriber Identity Modules (USIM) used for
authentication to 3GPP mobile networks, have application-specific interfaces
for
authentication, key agreement protocols etc.
%

A fundamental aspect of TEEs is how much of the application is placed in the TEE.
%
For larger devices that include general-purpose processors with TrustZone or
SGX, entire \mEdhoc{} and \mOscore{} implementations may reside inside the TEE.
%
For constrained IoT devices on the lower end of the scale, a TEE might have to be
implemented using a special-purpose integrated circuit.
%
In the latter case, it may be beneficial to follow a minimalistic approach, and
only store in the TEE the long-term key and operations that need access to it, to reduce cost.
%

In general, it might appear more secure to implement as much as possible inside the TEE, but there is a security trade-off.
%
Because security-critical code runs in the same area as where long-term keys
reside, an implementation error here risks leaking information of the key to
the adversary.
%
From this perspective, it might be beneficial to follow the minimalistic approach
even when having access to TrustZone or SGX.
%

A slightly more secure division of functionality is to keep both the long-term key and the session key inside the TEE and extend the interface to accept messages and return the (en/de)crypted counterpart, i.e. the interface exposes \mAead{} functions.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Formalization and Results}}
\label{sec:formalization}
% !TEX root = paper.tex
The \mEdhoc{} \mSpec{} \cite{our-analysis-selander-lake-edhoc-00} claims
that \mEdhoc{} satisfies many security properties, but these are imprecisely
expressed and motivated.
%
In particular, there is no coherent adversary model.
%
It is therefore not clear in which context properties should be verified.
%
We resolve this by clearly specifying an adversary model, in which we can 
verify
properties.
%

%---------------------------------------------------------------------- subsub
\subsection{Formal Model}\label{sec:threat-model}
As in~\cite{Norr21}, we verify \mEdhoc{} in an extended
Dolev-Yao model~\cite{DY83}.
%
The Dolev-Yao model is well established for the symbolic verification of 
security
protocols.
%
Messages are modelled as terms in an algebra, and the various cryptographic
operations are assumed to be perfect, e.g., encrypted messages can only be
decrypted with the correct key, there are no hash collisions etc.
%

The adversary is assumed to be in control of the communication
channel and can see all messages being communicated as part of the protocol.
%
In addition, they can interact with an unbounded number of protocol sessions,
and drop, inject and modify messages at will.
%

On top of the standard Dolev-Yao model, \cite{Norr21} allows the adversary to
access long-term and ephemeral keys via specific events.
%
Long-term key reveal, denoted by $\mRevLTK^{t}(A)$, stands for the adversary
gaining access to a party $A$'s long-term private key \mPriv{A} at a time point 
$t$.
%
Ephemeral key reveal, denoted by $\mRevEph^{t}(A, k)$, stands for the 
adversary
obtaining, at time $t$, the ephemeral private key \mPrivE{A} used by party $A$
in a session where they establish a session key $k$.
%
Formalizing these two capabilities allows more fine-grained control
over the access that an adversary has to these fundamentally different kinds of
keys.
%
Furthermore, we modify the model from~\cite{Norr21} by strengthening the
adversary capabilities, as detailed next.
%

%---------------------------------------------------------------------- subsub
\subsubsection{System and Adversary Model Extensions Supporting TEE.}
\label{sec:TEE:advModel}
%
We extend the adversary model of~\cite{Norr21} by allowing the adversary to 
use the long term key of any party via an interface, without directly accessing 
the key itself.
%
This allows us to model the scenario where the adversary has gained access to
a device, but the long-term key is protected by a trusted execution
environment (TEE), and thus only accessible via the TEE interface.
%
According to the terminology of~\cite{DBLP:conf/csfw/Cohn-GordonCG16}, a
protocol is considered to enjoy \emph{weak post-compromise security}
(Weak-PCS) if it achieves its security goals for a specific session
even when the following hold:
\begin{itemize}
\item Before the session starts, the adversary has limited access to the 
long-term 
keys of the parties involved, through an interface that securely maintains 
the keys but allows principals to run cryptographic operations using them, and
\item The adversary has full access to the keys of the parties involved after the 
end of the session, as well as access to the keys of all other parties.
\end{itemize}
%
As in the framework of~\cite{DBLP:conf/icics/XuZRWTZ20}, we add 
adversary
capabilities corresponding to a server adversary, i.e., upon 
compromising a party, the adversary learns their ephemeral keys and may temporarily access their TEE, but does not learn their long-term key.
%
This extension to the model of~\cite{Norr21} thus allows us to verify all the
previous security properties under a ``Weak-PCS model''.
%
Note that this attacker model is strictly more powerful than that 
of~\cite{Norr21}, as it subsumes the previous attacker capabilities.
%

We split the functionality of \mEdhoc{} as follows.
%
The TEE contains the long-term key and allows the non-TEE parts of the
application to perform the operations using it via an interface.
%
More precisely, parties using the \mSig{} authentication method use a TEE 
interface which accepts a message and returns the signature of that 
message using the party's private long-term key.
%
A party $U$ using the \mStat{} authentication method uses a TEE with an 
interface accepting a point $P$ on the curve and 
%returning $\mDH(P,\ \mGu{})$.
returning $\mDH(\mPriv{U},\ P)$.
%

%The non-TEE parts implement \mEdhoc{} using this interface.
%
This interface requires the least functionality from the TEE, reducing the 
TEE's complexity and (possibly) its cost.
%
This functional split is suitable even when a constrained device has
implemented the storage of only the long-term key in 
a special purpose circuit with minimal processing functionality.
%
Since \mEdhoc{} focuses on constrained IoT devices, it seems appropriate to
cater for this setting.
%

%---------------------------------------------------------------------- subsub
\subsubsection{Extended Formalism and Security Properties.}
\label{sec:TEE:fmAndProps}
Formally, we model the TEE interface by adding two new rewrite rules:
%
\begin{small}
\begin{verbatim}
rule forge_SIG:
   [!LTK_SIG($A, ~ltk), In(xx)] --[TEE($A)]-> [Out(sign(xx, ~ltk))]

rule exp_STAT:
   [!LTK_STAT($A, ~ltk), In('g'^~xx)] --[TEE($A)]-> [Out(('g'^~xx)^~ltk)]
\end{verbatim}
\end{small}
%
These rules allow the adversary to obtain terms representing signatures on a
value of their choice (\verb|forge_SIG|), or to obtain terms
representing a curve point of their choice raised to the power of the
long-term key (\verb|exp_STAT|).
%

Because it is a trivial attack when the adversary accesses these rules with values
from a session in progress, we must disqualify those rule applications.
%
We do so by creating an action fact \verb|TEE($A)|, where \verb|$A| is the
identity corresponding to the private key used, and then augmenting the
properties with a condition that no such action fact exists from the start of
the protocol execution till its end.
%
Care must be taken when specifying the start and the end: specifically,
the start and end of the execution must be viewed with respect to the current
role.
%
For example, the injective agreement property for the initiator in
the \mSigSig{} method requires that the adversary does not have access to the
TEE of the responder from the time that the first message is transmitted till
the second message is received by the initiator (or equivalently, till the third message is transmitted by the initiator, since reception of a message and transmission of the next one by a party is one atomic operation).
%
Thus, these timepoints represent the start and end of the
protocol run from the perspective of the initiator.
%

The second message encrypts two values: the responder's 
identity
\verb|R| and the authentication information \verb|authR|.
%
We model XOR encryption by \mXor-ing each term with their own key-stream 
term.
%
However for some problematic methods\footnote{See Table~\ref{tab:props} for all verification results and computation times.} we \mXor{} the entire tuple
\verb|<R, authR>| with a single key-stream term.
%
This simplification is likely to miss an attack on implicit authentication which occurs due to the combination of a malleable XOR encryption and access to the TEE 
interface.
%
However, given that no attacks were identified due to the use of XOR in our original modeling, nor in the current modeling for all other authentication methods, we believe that this is not a severe restriction.
%

Next we provide a quick overview of the \mTamarin{} tool, and describe our modeling of \mEdhoc{} in it.
%

%-------------------------------------------------------------------------- sub
\subsection{\mTamarin{}}
\label{sec:tamarin}
We extend the formal model of~\cite{Norr21}, using the tool \mTamarin{}~\cite{DBLP:conf/cav/MeierSCB13}, which is an 
interactive
tool for the symbolic verification of security protocols.
%
Protocols are modelled in \mTamarin{} as multiset rewrite rules which encode 
a
transition relation.
%
The elements of these multisets, called facts, contribute to the global
system state.
%
For syntactic sugar, \mTamarin{} also allows the use of let-bindings and tuples.
%
For ease of presentation, we will present the model and properties in a
slightly different syntax in this paper, but this syntax can be directly
mapped to that of \mTamarin.
%

Rewrite rules can be annotated with events, called actions in \mTamarin{}.
%
Communicated messages in the protocol are modelled as terms in an algebra,
which specifies sets of names, variables, and allowable function symbols.
%
Facts and actions are modelled as $n$-ary predicates in the term algebra,
and actions can be parametrized using terms.
%

An annotated multiset-rewrite rule is represented as
$l \ifarrow[e] r$, where $l$ and $r$ are multisets, and $e$ is
a multiset of actions.
%
A sequence of actions yields a protocol execution trace.
%
Properties are defined as formulas in a fragment of temporal first order logic,
and these formulas can be verified over execution traces.
%
Event types are predicates over global states generated during protocol 
execution.
%
Consider an event type $E$ and a timestamp $t$ as part of a trace.
%
By $E^{t}(p_i)_{i\in\mathbb{N}}$, we represent an event of type $E$ occurring
at time $t$ in a trace, parametrized by the sequence of values
$(p_i)_{i\in\mathbb{N}}$
(corresponding to the action fact $E(p_i)_{i\in\mathbb{N}}@t$ in \mTamarin).
%
Thus, the time points form a quasi order, and we denote the fact that
$t_{1}$ comes before $t_{2}$ in a protocol trace by
$t_{1} \lessdot t_{2}$, and that $t_{1}$ and $t_{2}$ stand for the same
time point in a trace by $t_{1} \doteq t_{2}$.
%
\mTamarin{} allows events to occur at the same time point, with one
restriction: multiple events of the same type cannot occur simultaneously,
so if $t_{1} \doteq t_{2}$, then $E^{t_{1}} = E^{t_{2}}$.
%

Protocol verification in \mTamarin{} happens under an equational theory $E$.
%
For example, to represent the fact that $E$ satisfies the reversal of
symmetric encryption by using a decryption operation with the key,
one can write $\textit{dec}(\textit{enc}(x, y), y) =_{E} x$.
%
The equational theory $E$ is fixed upfront to handle the functions supported 
by
the term algebra, so we will omit the subscript for the rest of this paper.
%

Users can extend the default term algebra and equational theory in
\mTamarin{} with new function symbols and unification rules (if any) for these new 
symbols.
%
For example, \mEdhoc{} requires authenticated encryption, which we model 
using
the symbol \mT{aeadEncrypt}.
%
We augment \mTamarin{} with the following rule for this operation,
which represents the fact that if the adversary knows a key \mT{k},
a message \mT{m}, and authenticated data \mT{ad},
and has access to an encryption algorithm \mT{ai},
then they can obtain the message corresponding to the authenticated 
encryption
of \mT{m} with \mT{k}~\cite{Norr21}.
%
{\footnotesize
\begin{verbatim}
[!KU(k), !KU(m), !KU(ad), !KU(ai)] --[]-> [!KU(aeadEncrypt(k, m, ad, ai))]
\end{verbatim}}
%
Other than modeling authenticated encryption, we use \mTamarin{}'s built-in
equational theories for signing, Diffie-Hellman, hashing and \mXor{}.
%

Tamarin has also built-in rules for modeling a Dolev-Yao adversary and the
evolution of their knowledge as the protocol executes.
%
We extend the Dolev-Yao adversary model by adding other rules that increase
the capabilities of the attacker.
%
To denote that the adversary has access to a message $p$ at time $t$, we use 
$\mK^{t}(p)$.
%
As an example, the following implication
\[
    \forall t, k, k'\mLogicDot \mK^{t}(\langle k, k'\rangle)\ \rightarrow\
\mK^{t}(k) \land \mK^{t}(k'),
\]
models the fact that if the adversary gets to know the pair of
keys $\langle k, k' \rangle$ at a time point $t$, then the adversary
knows each of those keys $k$ and $k'$ at time point $t$ as well.
%
For more details about how \mTamarin{} manages adversary knowledge,
see~\cite{DBLP:conf/cav/MeierSCB13}.
%

%-------------------------------------------------------------------------- sub
\subsection{Model and Desired Properties}
\label{sec:desired-properties}
In this section, we describe our modeling of \mEdhoc{} and its desired
security properties.
%

The party $I$ executing the initiator role considers a run of the protocol
begun as soon as it sends the first message \mMsgone{} with event type
\mIStart, and considers the run ended once it has sent the third message
\mMsgthree{} with event type \mIComplete.
%
Similarly, the responder $R$ considers a run started upon receiving 
\mMsgone{}
with event type \mRStart, and finished upon receiving \mMsgthree{} with 
type
\mRComplete.
%

In this work we consider the following properties: secrecy of the session key,
injective agreement and implicit agreement on the session-key material for 
both
initiator and responder, and secrecy and integrity of the application data sent
as part of message 3 ($\mAD_3$).
%
Agreement is considered on a set of parameters $S$ which also contains the
session-key material \mSessKey{}.
%
We will first describe in detail all these properties, and then describe the
contents of the set $S$.
%
We formalize these properties as shown in Figure~\ref{fig:props}, which is
a modified version of a figure in~\cite{Norr21}.
%
%Note that the properties in Figure~\ref{fig:props} are unlike the actual \mTamarin{} lemma in one minor way -- in the \mTamarin{} code, we only check that the TEE is accessed after the start of the session, since the long-term key reveal event covers the reveal of all long-term and session keys after the end of the session.
%\vnote{Check that this is right}

\begin{figure*}[htp]
\begin{align*}
    \mPredPcs \triangleq\ & \forall \mTID, I, R, \mSessKey, t_2, t_3\mLogicDot
    \mK^{t_3}(\mSessKey)\  \land\ 
    (\mIComplete^{t_2}(\mTID, I, R, \mSessKey)\, \lor\, 
\mRComplete^{t_2}(\mTID, 
I, R, 
\mSessKey))
    \rightarrow\\
    &(\exists t_1\mLogicDot \mRevLTK^{t_1}(I) \land t_1 \lessdot t_2)
    \ \lor\ (\exists t_1\mLogicDot \mRevLTK^{t_1}(R) \land t_1 \lessdot t_2)\\
    &\ \lor\ (\exists t_1\mLogicDot \mRevEph^{t_1}(R, \mSessKey))
    \ \lor\ (\exists t_1\mLogicDot \mRevEph^{t_1}(I, \mSessKey))\\
	&\ \lor\ (\exists t_0, t_1, Z'\mLogicDot \mIStart^{t_0}(\mTID, I, R, Z') \land 
\mTEE^{t_1}(R) \land (t_0 \lessdot t_1 \land t_1 \lessdot t_2))\\
    &\ \lor\ (\exists t_0, t_1, Z'\mLogicDot \mRStart^{t_0}(\mTID, I, R, Z') 
\land \mTEE^{t_1}(I) \land (t_0 \lessdot t_1 \land t_1 \lessdot t_2))\\[1em]
%    &\ \lor\ (\exists t_0, t_1\mLogicDot \mRStart^{t_0}(\mTID, R, \mSessKey, S) 
%\land \mTEE^{t_1}(I) \land (t_0 \lessdot t_1 \land t_1 \lessdot t_2))\\[2em]
%
    \mPredInjI \triangleq\ &
    \forall \mTID_I, I, R, \mSessKey, S, t_2\mLogicDot \mIComplete^{t_2}(\mTID_{I}, I, R, 
\mSessKey, S)
    \rightarrow\\
    &(\exists \mTID_R, t_1\mLogicDot \mRStart^{t_1}(\mTID_R, R, \mSessKey, 
S) \land t_1 \lessdot t_2
    \land (\forall \mTID_I', I', R', t_1' \mLogicDot \mIComplete^{t_1'}(\mTID_I', 
I' , R', \mSessKey, S)
        \rightarrow t_1' \doteq t_2))\\
    &\ \lor\ (\exists t_1\mLogicDot \mRevLTK^{t_1}(R) \land t_1 \lessdot t_2)\\
    &\ \lor\ (\exists t_0, t_1, Z'\mLogicDot \mIStart^{t_0}(\mTID_I, I, R, Z') \land 
\mTEE^{t_1}(R) \land (t_0 \lessdot t_1 \land t_1 \lessdot t_2))\\[1em]
%
    \mPredInjR \triangleq\ &
    \forall \mTID_R, I, R, \mSessKey, S, t_2\mLogicDot 
\mRComplete^{t_2}(\mTID_R, 
I, R, 
\mSessKey, S)
    \rightarrow\\
    &(\exists \mTID_I, t_1\mLogicDot \mIStart^{t_1}(\mTID_I, I, R, \mSessKey, 
S) \land t_1 \lessdot t_2
    \land (\forall \mTID_R', I' R' t_1' \mLogicDot 
\mRComplete^{t_1'}(\mTID_R', 
I' , R', \mSessKey, S)
        \rightarrow t_1' \doteq t_2))\\
    &\ \lor\ (\exists t_1\mLogicDot \mRevLTK^{t_1}(I) \land t_1 \lessdot t_2)\\
    &\ \lor\ (\exists t_0, t_1, Z', S'\mLogicDot \mRStart^{t_0}(\mTID_R, R, 
Z', S') \land \mTEE^{t_1}(I) \land (t_0 \lessdot t_1 \land t_1 \lessdot 
t_2))\\[1em]
%
    \mPredImpI \triangleq\ &
    \forall \mTID_I, I, R, \mSessKey, S, t_1\mLogicDot 
\mIComplete^{t_1}(\mTID_I, 
I, R, \mSessKey, 
S)
    \rightarrow\\
      &(\forall \mTID_R, I', R', S', t_2\mLogicDot \mRComplete^{t_2}(\mTID_R, 
I', R', \mSessKey, S') \rightarrow
             (I=I' \land R=R' \land S=S')\\
      &\ \land (\forall \mTID_I', I', R', S', t_1'\mLogicDot
        \mIComplete^{t_1'}(\mTID_I', I', R', \mSessKey, S') \rightarrow t_1' \doteq 
t_1
        ))\\
    &\lor(\exists t_0\mLogicDot \mRevLTK^{t_0}(R) \land t_0 \lessdot t_1)
    \lor(\exists t_0\mLogicDot \mRevEph^{t_0}(R, \mSessKey))
    \lor(\exists t_0\mLogicDot \mRevEph^{t_0}(I, \mSessKey))\\
    &\lor\ (\exists t_0, t_1, Z'\mLogicDot \mIStart^{t_0}(\mTID_I, I, R, Z') \land 
\mTEE^{t_1}(R) \land (t_0 \lessdot t_1 \land t_1 \lessdot t_2))\\[1em]
%
	\mSecADthree \triangleq\ &
	\forall \mADthree, I, R, \mSessKey, \mTID_{I}, t_{3}, t_{2}\mLogicDot  \mK^{t_{3}}(\mADthree) \land \mISend^{t_{2}}(I, R, \mSessKey, \mADthree, \mTID_{I}) \rightarrow \\
	& ( (\exists t_{1}\mLogicDot \mRevLTK^{t_{1}}(I) \land t_{1} \lessdot t_{2})\lor(\exists t_{1}\mLogicDot \mRevLTK^{t_{1}}(R) \land t_{1} \lessdot t_{2}) \\
	&\ \ \lor(\exists t_0\mLogicDot \mRevEph^{t_0}(R, \mSessKey))
     \lor(\exists t_0\mLogicDot \mRevEph^{t_0}(I, \mSessKey)) \\
    &\ \ \lor(\exists t_{0}, t_{1}, Z'\mLogicDot \mIStart^{t_{0}}(\mTID_{I}, I, R, Z') \land \mTEE^{t_{1}}(R) \land t_{0} \lessdot t_{1}) \\
    &\ \ \lor(\exists t_{0}, t_{1}, t_{4}, \mTID_{R}, Z', S'\mLogicDot \mTEE^{t_{1}}(I) \land \mRRecv^{t_{4}}(I, R, Z, \mADthree, \mTID_{R}) \land \mRStart^{t_{0}}(\mTID_{R}, R, Z', S') \land t_{0} \lessdot t_{1}))\\[1em]
%
	\mIntADthree \triangleq\ &
	\forall \mADthree, I, R, \mSessKey, \mTID_{R}, t_{3}\mLogicDot 
	\mRRecv^{t_{3}}(I, R, \mSessKey, \mADthree, \mTID_{R}) \rightarrow \\
	& ( (\exists \mTID_{I}, t_{2}\mLogicDot \mISend^{t_{2}}(I, R, \mSessKey, \mADthree, \mTID_{I}) \land t_{2} \lessdot t_{3}) \\
	&\ \lor (\exists t_{2}\mLogicDot \mRevLTK^{t_{2}}(I) \land t_{2} \lessdot t_{3}) \lor(\exists t_{2}\mLogicDot \mRevLTK^{t_{2}}(R) \land t_{2} \lessdot t_{3}) \\
	&\ \ \lor(\exists t_0\mLogicDot \mRevEph^{t_0}(R, \mSessKey))
     \lor(\exists t_0\mLogicDot \mRevEph^{t_0}(I, \mSessKey)) \\
     &\ \ \lor(\exists t_{0}, t_{1}, t_{2}, \mTID_{I}, Z'\mLogicDot \mTEE^{t_{1}}(R) \land \mISend^{t_{2}}(I, R, \mSessKey, \mADthree, \mTID_{I}) \land \mIStart^{t_{0}}(\mTID_{I}, I, R, Z') \land t_{0} \lessdot t_{1}) \\
     &\ \ \lor(\exists t_{0}, t_{1}, Z', S'\mLogicDot \mTEE^{t_{1}}(I) \land \mRStart^{t_{0}}(\mTID_{R}, R, Z', S') \land t_{0} \lessdot t_{1})
	)
\end{align*}
\caption{Formalization of security properties}
\label{fig:props}
\end{figure*}


%----------------------------------------------------------------------- PFS
\subsubsection{Secrecy of the Session-Key Material.}
\label{sec:secrecy}
We show that the adversary cannot gain access to the session-key material
\mSessKey{}, even under the weak post-compromise security model which allows 
the
adversary limited access to the long-term keys of the involved parties via
a
secure interface before the session starts, and unrestricted access to the long-term
keys of all parties as well as access to all other session keys after the session ends.
%
This property is formalized as \mPredPcs{} in Figure~\ref{fig:props}.
%

In the \mIComplete{} event, \mTID{} represents a ``thread identifier'' which uniquely identifies the
current session, $I$ represents the identity of the initiator,
and $R$ represents the identity of the party who the initiator believes is
playing the responder role, while \mSessKey{} stands for the established
session-key material.
%
\mRComplete{} has analogous parameters; in particular, the responder $R$
believes $I$ is the party playing the initiator role.
%
Intuitively, the PCS property states that an adversary obtains \mSessKey{}
only if one of the following conditions hold: either a party's long-term key
is compromised before their run ends, or the TEE interface for the responder is used during the current
session for the initiator, i.e., after the initiator starts and before it
completes, or, similarly, the TEE interface for the initiator is used during the
current session for the responder.
%
Note that the properties in Figure~\ref{fig:props} are unlike the actual \mTamarin{} lemma in one minor way: \mTamarin's logic does not allow disjunctions to appear on
the left-hand side of an implication inside a universally-quantified formula.
%
Therefore, in the \mTamarin{} code, instead of using the disjunction
$\mIComplete^{t_2}(\mTID, I, R, \mSessKey)\, \lor\,
\mRComplete^{t_2}(\mTID, I, R, \mSessKey)$
to model the fact that either party may have completed their execution, we use
a single action parametrized by the terms $\mTID$, $I$, $R$, and \mSessKey.

%-------------------------------------------------------------------- InjAgree
\subsubsection{Authentication Properties.}
\label{sec:authenticationDef}
Following~\cite{Norr21}, we prove two different kinds of authentication
properties, namely \emph{injective agreement} in the style
of~\cite{DBLP:conf/csfw/Lowe97a}, and implicit agreement.
%
Injective agreement can be guaranteed to either party running the protocol.
%
For the initiator $I$, it guarantees to $I$ that whenever $I$ believes that
they have completed a run with $R$ as responder, then the party $R$ has 
indeed
executed the protocol in the role of a responder, and that this run of $I$
uniquely corresponds to one of $R$ where the set of parameters is $S$ and
includes, in particular, the session-key material \mSessKey{}.
%
It can be defined for $R$ in a similar manner.

%
We formalize injective agreement for the initiator role as \mPredInjI{} and
for the responder role as \mPredInjR{} in Figure~\ref{fig:props}.
%
For the initiator $I$, this property represents the fact that either
injective agreement (as described above) holds, or the long-term key of
the party $R$ assumed to be playing the responder role has been
compromised before $I$'s role finished.
%
The property should hold even if the adversary has access to the TEE of party 
$R$
before and after the protocol execution.
%%
An analogous definition holds for the responder $R$.
%
%As part of the formalization, note that we parametrize the \mIStart{} and \mRStart{} events with some subset of \mTID, $I$, $R$, and $Z$, as well as the set $S$ of parameters upon which we check for agreement.
%%
%The set $S$ will often include the other party's identity, so, for example, \mRStart{} will not mention the term $I$ as a parameter outside of $S$, and instead just be parametrized by \mTID, $R$, $Z$, and $S$.

%------------------------------------------------------------- Implicit auth
As part of our analysis, we found that all the \mEdhoc{} methods satisfy weak
post-compromise security.
%
However, this is not the case for the injective agreement property as stated 
above.
%
Thus, we show a different property, a form of implicit agreement on the same
set of parameters, which is guaranteed for all methods.
%
This modification is inspired by the definitions of implicit authentication in
the computational model~\cite{DBLP:conf/csfw/GuilhemFW20}.
%
While that paper focuses on authenticating just a key and related identities,
our definition encompasses a general set of parameters, as in the notion of
injective agreement proposed by Lowe~\cite{DBLP:conf/csfw/Lowe97a}.

The ``implicit'' in the name of the property stands for the fact that a party
$A$ assumes that any party $B$ who has access to the session-key material
\mSessKey{} must, in fact, be the intended party, and that if $B$ is honest,
$B$ will agree on a set $S$ of parameters which includes \mSessKey.
%
Implicit agreement for both roles guarantees to $A$ that $A$ is or has been
involved in exactly one protocol execution with $B$, and that $B$ agrees or
will agree with $A$ on $S$.
%
This property diverges from injective agreement in that upon sending
the last message, $A$ concludes that if this message reaches $B$, then $A$
and $B$ agree on each other's identities and roles, as well as the set $S$.
%

Note that for implicit agreement to hold for $I$, the ephemeral keys must not
be revealed since the property relies on the fact that the intended responder
is the only one who knows the session-key material.
%
If the adversary has access to the ephemeral keys, they can use them along 
with
the public keys of $I$ and $R$ to compute the session-key material.
%
However, either party's long-term key can be revealed after the other
party has finished their execution, since this still leaves the adversary
unable to compute \mGxy{}.
%

Since \mTamarin{} runs out of memory to verify this property as is,
we split it into two lemmas -- \mPredImpI{} for $I$ for one \mPredImpR{} for 
$R$.
%
Figure~\ref{fig:props} contains the definition for \mPredImpI{}.
%
\mPredImpR{} is formalized similarly, so we omit it.
%

%------------------------------------------------------- Agreed parameters
\subsubsection{Set $S$ of Agreed Parameters.}
\label{sec:agreedParams}
We now describe the set $S$ of parameters upon which the two parties obtain
guarantees via the above properties.
%
The initiator $I$ gets injective and implicit agreement guarantees on the
following partial set $S_P$ of parameters~\cite{Norr21}:
\begin{itemize}
    \item the roles played by itself and its peer,
    \item responder identity,
    \item session-key material (which varies depending on the \mEdhoc{} 
method),
    \item context identifiers \mCi{} and \mCr{}, and
    \item cipher suites \mSuites{}.
\end{itemize}
%

Due to the initiator being guaranteed identity protection under \mEdhoc{}, $I$
cannot get explicit agreement with $R$ on the initiator's identity.
%
Similarly, when using the \mStat{} authentication method, $I$ does not get 
any
such guarantees about $P_{I}$.
%
However, $I$ does get implicit agreement with $R$ about $I$'s identity and the
full set $S_{F}$ of agreed parameters.
%
In contrast, since $R$'s run finishes after that of $I$, $R$ can get explicit
injective agreement assurances on the full set $S_{F}$ of agreed parameters.
%
The full set of agreed parameters $S_F$ is $S_P \cup \{I, P_I\}$ when $P_I$
is part of the session-key material, and $S_P \cup \{I\}$ otherwise.
%

In addition to these properties, a couple of properties can be inferred
without being explicitly modelled and verified.
%
One such property is Key-Compromise Impersonation
(KCI)~\cite{DBLP:conf/ima/Blake-WilsonJM97}.
%
A KCI attack occurs when an adversary who has access to $A$'s long-term 
private
key to make $A$ believe that they completed an execution with a peer $B$,
while $B$ did not participate in said execution at all.
%
This is in particular relevant when \mStat{} authentication methods are used.
%
Our above notions of agreement ensure that both parties agree on each
other's identity, role, and session-key material.
%
Therefore, all \mEdhoc{} methods that satisfy these agreement properties also
avoid KCI attacks.
%

Another kind of attack is Unknown Key Share attacks
(UKS)~\cite{DBLP:conf/ima/Blake-WilsonJM97}.
%
As part of a UKS attack, a party $A$ can be made to believe that it finished
an execution with a party $B$, but where the session-key material is actually
shared between $A$ and $C$ instead.
%
Again, due to the agreement on identities and session-key material, any 
method
that satisfies the above agreement properties also resists UKS attacks.
%
Overall, the agreement properties capture entity authentication,
and satisfy any properties based on that notion.
%
However, see Section~\ref{sec:unintendedPeerAuth} for a discussion on the
interaction between \mEdhoc{} and the application leading to similar issues.
%

%---------------------------------------------------------------------------sub
\subsection{Encoding \mEdhoc{} in \mTamarin{}}
\label{sec:modeling}
%
In this section, we describe how we model the \mSigSig, \mSigStat, \mStatSig,
and \mStatStat{} methods of \mEdhoc{} in \mTamarin.
%
As in~\cite{Norr21}, we construct the \mTamarin{} model by utilizing the fact
that all methods of \mEdhoc{} share a common underlying structure
(as shown in Figure~\ref{fig:edhocFramework}).
%
We do so by using a single specification file in the M4 macro language,
which generates all the methods.
%
As in~\cite{Norr21}, we only present the \mStatSig{} method which illustrates
the use of two different authentication methods.
%
The full \mTamarin{} code for all models can be found 
at~\cite{dropboxrepo}.
%

As mentioned in Section~\ref{sec:tamarin}, we extend the default
equational theory of \mTamarin{} to handle various operations used in 
\mEdhoc.
%
Of the built-in theories, we use the ones for exclusive-or (\mXor),
Diffie-Hellman operations, signatures (\mT{sign} and \mT{verify} operations),
and 
hashing~\cite{DBLP:conf/csfw/DreierHRS18,DBLP:conf/csfw/SchmidtMCB12}.
%
We 
%augment the hashing function symbol to add an extra input, which we use 
to
model different hash functions.
%

In addition to these default operations, \mEdhoc{} is built over the following functions: \mHkdfExpand, \mHkdfExtract, and \mAead{}.
%
We represent \mHkdfExpand{} by \mT{expa} and \mHkdfExtract{} by 
\mT{extr}.
%
\mAead{} operations need us to add extra equations to the underlying theory.
%
A term encrypted using the \mAead{} algorithm is represented by \mT{aeadEncrypt(m, k, ad, 
ai)},
where \mT{m} is the underlying message, \mT{k} is the encrypting key,
\mT{ad} is the additional data, and \mT{ai} is the identifier for the
encryption algorithm.
%
Decryption of such a term is defined via two equations that we add to
\mTamarin's theory.
%
The following equation requires the decrypting party to know the additional
data \mT{ad} to decrypt this encrypted term with verification of its integrity.
\begin{small}
\begin{verbatim}
aeadDecrypt(aeadEncrypt(m, k, ad, ai), k, ad, ai) = m.
\end{verbatim}
\end{small}
%
Only the above equation is used by honest parties, but the adversary should
also be able to decrypt without having to go through the additional step of
identity verification.
%
To this end, we also add the following equation, where the adversary does not
need access to the additional data \mT{ad} in order to decrypt.
%
\begin{small}\begin{verbatim}
decrypt(aeadEncrypt(m, k, ad, ai), k, ai) = m.
\end{verbatim}\end{small}
%

Having described how we adapt the equational theory to model \mEdhoc,
we now move on to the modeling of the adversary model and the 
environment in
which the protocol is executed.
%
We extend the built-in Dolev-Yao adversary rules which are part of 
\mTamarin.
%
We use the following rules to capture the link between a party's identity and
their long-term key pairs, in the \mSig{}- and in the \mStat{}-based methods
respectively.
\begin{center}
\begin{minipage}{0.48\textwidth}
\begin{scriptsize}
\begin{verbatim}
1 rule registerLTK_SIG:
2    [Fr(~ltk)] --[UniqLTK($A, ~ltk)]->
3        [!LTK_SIG($A, ~ltk),
4         !PK_SIG($A, pk(~ltk)),
5         Out(<$A, pk(~ltk)>)]
\end{verbatim}
\end{scriptsize}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{0.48\textwidth}
\begin{scriptsize}
\begin{verbatim}
1 rule registerLTK_STAT:
2    [Fr(~ltk)] --[UniqLTK($A, ~ltk)]->
3        [!LTK_STAT($A, ~ltk),
4         !PK_STAT($A, 'g'^~ltk),
5         Out(<$A, 'g'^~ltk>)]
\end{verbatim}
\end{scriptsize}
\end{minipage}
\end{center}

Using the fact \verb|Fr(~ltk)|, \mTamarin{} creates a new term \mT{ltk} and 
uses
it to represent a secret long-term key.
%
Via the \verb|Out(<$A, pk(~ltk)>)| fact, \mTamarin{} puts out onto the
communication channel the identity of the party to whom this long-term
key belongs, along with their public key.
%
Since the adversary has access to the communication channel, they can pick 
up
all of this information.
%
The event \mT{UniqLTK} parametrized by a party's identity and their 
long-term
key 
models the unique correspondence between those two values.
%
As a result, this rules out a party owning multiple long-term keys
-- in particular, it keeps the adversary from registering long-term keys in
some honest party's name.
%
This aligns well with an external mechanism such as a certificate authority
ensuring that long-term keys are uniquely assigned to the corresponding
identities, which is ensured by the \mSpec.

To model the reveal of long-term keys and ephemeral keys to an adversary,
we use standard reveal rules and events of type \mRevLTK{} and \mRevEph,
respectively.
%
It is also important to keep track of the time points at which these events 
occur.
%
Long-term keys can be revealed on registration, even before the protocol 
begins.
%
Ephemeral keys in our model can only be revealed when a party
completes their role, i.e., simultaneously with events of type \mIComplete{}
and \mRComplete.
%
Having set out the capabilities of the adversary, we now model the execution
of the honest agents' roles.
%

For each protocol method, we use two rules apiece for the initiator and
responder -- \mT{I1}, \mT{R2}, \mT{I3}, \mT{R4}.
%
Each of these stand for one step of the protocol as executed by either party.
%
To disambiguate, we will attach the method to the rule name.
%
These four rules directly map to the event types
\mIStart, \mRStart, \mIComplete, and \mRComplete, respectively.
%
We show the \mT{R2\_STAT\_SIG} rule below to illustrate the various aspects
of the \mTamarin{} modeling we are describing here.
%

In order to keep track of the initiator's state, we use facts prefixed with
\mT{StI}, which carry information between the \mT{I1} and \mT{I3} rules.
%
Similarly, for the responder's state, we have \mT{StR} to carry state data
between \mT{R2} and \mT{R4}.
%
In order to link two rules to a state fact, we use \mT{tid}, which
is unique to the current session.
%
The use of these state facts can be seen in line 28 in the \mT{R2\_STAT\_SIG} 
rule.
%

Note that we do not model any error message that $R$ might send in response
to message \mMsgone{} rejecting $I$'s choice of ciphersuite and/or method.
%

As in~\cite{Norr21}, we model the \mXor{} encryption of 
\mT{CIPHERTEXT\_2} with
the key \mT{K\_2e} by allowing each part of the encrypted term to be
separately attacked.
%
This means that we first expand \mT{K\_2e} to the same number of key terms 
as
subterms in the plaintext tuple.
%
This is done by applying \mHkdfExpand{} to unique inputs per subterm.
%
After this, we \mXor{} each subterm with its own key term.
%
This is more faithful to the \mSpec{} than \mXor-ing \mT{K\_2e} on its own
with the plaintext tuple.
%
This can be seen in lines 18--21 in the code for \mT{R2\_STAT\_SIG}.
%

As we extended the model with TEEs and augmented the adversary's 
capabilities
with access to them, \mTamarin{} failed to complete in a reasonable time for
some combination of authentication methods and security properties (see 
Section~\ref{sec:conclusion} for a detailed discussion).
%
To circumvent the problem, we simplified the \mXor{} encryption to 
\mXor-ing 
a
single term on the entire tuple for these cases. \\
%

{\parindent 0pt
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{verbatim}
1 rule R2_STAT_SIG:
2 let
3    agreed = <CS0, CI, ~CR>
4    gx = 'g'^xx
5    data_2 = <'g'^~yy, CI, ~CR>
6    m1 = <'STAT', 'SIG', CS0, CI, gx>
7    TH_2 = h(<$H0, m1, data_2>)
8    prk_2e = extr('e', gx^~yy)
9    prk_3e2m = prk_2e
10   K_2m = expa(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
12   protected2 = $V // ID_CRED_V
13   CRED_V = pkV
14   extAad2 = <TH_2, CRED_V>
15   assocData2 = <protected2, extAad2>
16   MAC_2 = aead('e', K_2m, assocData2, $cAEAD0)
17   authV = sign(<assocData2, MAC_2>, ~ltk)
18   plainText2 = <$V, authV>
19   K_2e = expa(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
20   K_2e_1 = expa(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
21   K_2e_2 = expa(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
22   CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2>
23   m2 = <data_2, CIPHERTEXT_2>
24   exp_sk = <gx^~yy>
25   in
26   [!LTK_SIG($V, ~ltk), !PK_SIG($V, pkV), In(m1), Fr(~CR), Fr(~yy), Fr(~tid)]
27   --[ExpRunningR(~tid, $V, exp_sk, agreed), R2(~tid, $V, m1, m2)]->
28   [StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2, agreed),
29    Out(m2)]
\end{verbatim}
\end{scriptsize}
\end{minipage}}
\vspace{5mm}

As mentioned earlier, we use actions to represent parametrized events.
%
For example, in line 27 above, the action
\verb|ExpRunningR(~tid, $V, exp_sk, agreed)| represents an event of type
\mRStart{} parametrized by the session id, the responder's identity, and the
session-key material \mT{exp\_sk}.
%
The \mT{exp} in the name of the variable for session-key material represents
the fact that the agreement property satisfied by this key is explicit, i.e.,
it includes $P_{I}$, as in Section~\ref{sec:agreedParams}.
%
We use \mT{imp\_sk} for the corresponding session-key material which does 
not
include $P_{I}$.
%
For the \mSigSig{} and \mSigStat{} methods, therefore, the two values are the
same.
%

The properties we listed in Section~\ref{sec:desired-properties}
translate directly into \mTamarin's logic.
%
We show the \mTamarin{} lemma which encodes the \mPredPcs{} property.
%
Other properties are formalized similarly. 
%

\begin{scriptsize}
\begin{verbatim}
1 lemma secrecyPCS:
2    all-traces
3    "All u v sk tid #t3 #t2.
4       (K(sk)@t3 & CompletedRun(u, v, sk, tid)@t2) ==>
5       ( (Ex #t1. LTKRev(u)@t1 & #t1 < #t2)
6       | (Ex #t1. LTKRev(v)@t1 & #t1 < #t2)
7       | (Ex #t1. EphKeyRev(sk)@t1)
8       | (Ex m1 #t0 #k. I1(tid, u, v, m1)@t0 & TEE(v)@k & (t0 < k | k < t2))
9       | (Ex m1 m2 #t0 #k. R2(tid, v, m1, m2)@t0 & TEE(u)@k & (t0 < k | k < t2))
10    )"
\end{verbatim}
\end{scriptsize}
%

In this formalization, we use the action \mT{CompletedRun(u, v, sk)}
(in line 4) to represent the disjunction of the events $\mIComplete^{t_{2}}$
and $\mRComplete^{t_{2}}$.
%
As expected, this action is emitted by both \mT{I3} and \mT{R4}.
%
Similarly, the action \mT{EphKeyRev(sk)} in line 7 stands for the reveal of
the ephemeral key for $I$ or $R$ or both.
%
Lines 8 and 9 captures that the parties TEEs must be inaccessible to the
adversary between the start and end of the execution as seen by each party
respectively.
%
The entire code can be found at~\cite{dropboxrepo}.
%-------------------------------------------------------------------------- sec
\section{\uppercase{Error Handling}}
\label{sec:errorHandling}
Section 6 of the current \mEdhoc{}
specification~\cite{draft-ietf-lake-edhoc-15}
states that error messages can be sent at any time and by any party.
%
There are three types of error messages: type 0 is used to represent success,
type 1 represents a generic error message used for debugging purposes, and
type 2 represents the failure to negotiate a common ciphersuite.
%
Type 2 messages carry a list of supported ciphersuites by the responder.
%
The contents and semantics of type 1 messages are dependent on the
implementation.
%
Consequently, type 1 error messages provide a generic message passing
mechanism, albeit without a predefined semantics.
%
We now discuss some issues with this specification of error messages.
%
In this section, we use ``specification'' to mean the latest specification, as
in~\cite{draft-ietf-lake-edhoc-15}.

\subsection{Lack of Connection Identifiers}
Error messages do not include the optional connection identifiers \mCi{} or
\mCr{}.
%
This is potentially problematic for connection-less transport layers, where
these identifiers may be used to correlate messages.

\subsection{Proper Reception Handling}
\mEdhoc{} provides an error message mechanism, but little to no guidance on
how it should be used safely.
%
For example, assume that an application using \mEdhoc{} logs error messages
on a finite log with rotation.
%
If the log is used for anomaly detection or detection of sensitive events, then
an adversary can simply inject error messages and fill the log until the
sensitive event is overwritten.
%
In such situations, implementers should do proper log-separation and log
management.

\subsection{Unspecified Semantics for Debugging Messages}
Section 6.2 gives an example of sending a type 1 error message with the
information string ``Method not supported".
%
Note that \mEdhoc{} does not include a mechanism to support the
negotiating of the connection method.
%
The initiator selects the method as part of the first message, and if the
responder replies with a type 1 error message along with the information
string ``Method not supported", the standard does not tell an
implementation how to act upon this information string for negotiation
purposes.
%
An adversary can fake an error message, and there is no algorithm that is
specified to ensure that a common available authentication mechanism is
always selected.
%
In particular, note that Section 5.1 in the specification states that if processing
fails for some reason, then ``typically" an error message is sent, processing is
terminated, and protocol state is discarded.
%
But negotiation needs us to remember state.

With respect to ciphersuite negotiation, Section 5.2.2 of the specification also
states ``The Initiator MUST NOT change the supported cipher suites and
the order of preference in SUITES\_I based on previous error messages.''
%
However, \mSuites{} is sent in the clear, and therefore can be modified by the
adversary.
%
It is important to consider what happens if the order of preference in
\mSuites{} is changed either by the adversary, or by the initiator themselves
for some other reason.
%
It might be helpful to include a flag in \mMsgone{} to indicate to the
responder
that a (modified) ciphersuite ordering depends on that from a previous
execution.

%-------------------------------------------------------------------------- sec
\section{\uppercase{Improvements to the Specification}}
\label{sec:discussion}
The \mEdhoc{} \mSpec{} has many points where it can be improved.
%
We discovered a few of these issues in~\cite{Norr21}, but in this work,
we also discuss a couple of new issues.
%
We communicated the points discussed in~\cite{Norr21} to the authors of the
\mSpec{}.
%
Here, we also list the protocol developers' response (if any) to being told of these
ambiguities in the \mSpec{}.

%-------------------------------------------------------------------------- sub
\subsection{Unclear Intended Use}
\label{sec:unclearProtocolUse}
%
There are several security goals listed in the \mSpec{}.
%
However, these goals are informal and imprecisely specified, and the lack of
intended usage makes them difficult to interpret.
%
Since we have little indication about use case restrictions, it is also hard
to evaluate whether the security goals are the most relevant ones.
%

In order to identify security goals that might be relevant
we made up some user stories corresponding to typical use cases,
which helped us identify some subtle points of concern in \mEdhoc.
%
We communicated these points to the authors of \mEdhoc{}.
%

%----------------------------------------------------------------------- subsub
\subsubsection{Non-Repudiation.}
Access control mechanisms can vary depending on what the underlying application
is.
%
A nuclear power-plant might need to keep track of who enters and leaves, but a
coffee machine that logs every user and their coffee preference might lead to a
privacy concern.
%
This simple thought experiment allowed us to identify that the \mEdhoc{}
\mSpec{} did not even consider non-repudiation.
%
When we pointed this out to the authors of the \mSpec, they recognized this
concern, and added a discussion about how the various \mEdhoc{} methods
satisfy (or not) non-repudiation.
%

%----------------------------------------------------------------------- subsub
\subsubsection{Unintended Peer Authentication.}
\label{sec:unintendedPeerAuth}
In Section~3.2 in the \mSpec{}, the authors state that parties executing
\mEdhoc{} must be configured such that they only run \mEdhoc{} with a
restricted (according to some reasonable policy) set of peers.
%
However, the responsibilities of verifying which identity was authenticated is
not clearly split between the application and \mEdhoc{} and therefore an attack
similar in effect to UKS is possible.
%

Suppose a person configures the restriction policy such that every device in
their home is allowed to set up an \mEdhoc{} session with any other device in
the home.
%
However, the adversary has managed to gain control of one of these devices (say
$A$).
%
Device $A$ is part of the allowed group of devices, so $B$ will accept an
\mEdhoc{} run with $A$, even though $A$ is now compromised.
%
If the application in $B$ tasks the \mEdhoc{} implementation to establish a
security context with $C$, $B$ will send an initial message to $C$.
%
However, if $A$ responds to the initial message before $C$ can, the \mSpec{}
does not require $B$ to verify that \mIdcredr{} matches what is expected for
$C$.
%
A valid \mEdhoc{} implementation may then look up the appropriate credentials
for $A$, complete the execution and deliver the security context to the
application.
%
The application gets no indication of that the security context is shared with
$A$ rather that $C$ as intended.
%

A straight forward check that the received \mIdcredr{} matches the expected
identity thwarts the problem.
%
We included this check in our model.
%
We communicated this to the authors of \mEdhoc{}, who in the latest version of
the \mSpec{}, added that \mEdhoc{} makes \mIdcredr{} available to the
application, and added an appendix D listing credential validations that
the application must take care of.
%

%----------------------------------------------------------------------- subsub
\subsubsection{Denial of Service.}
Denial of Service (DoS) attacks for IoT protocols are well-studied,
but DoS aspects particular to \mEdhoc{} is not.
%
The \mSpec{} does not include any specific measures countering such
attacks, but assumes the application takes care of it.

Section 8.7 of the latest version of the \mEdhoc{}
\mSpec{}~\cite{draft-ietf-lake-edhoc-15}
gives two recommendations for countering DoS attacks.
%
First, \mEdhoc{} relies on lower layers to mitigate DoS, and an example of DoS
countermeasures is given: checking the return address upon receipt of the first
message.
%
Second, a recommendation is given that applications may try to determine (in
some way) that a seemingly valid message is in fact probably a forgery and
should be ignored or cause the protocol to abort.
%

No recommendation is given on how to minimize DoS effects stemming from the use
of error messages, which can be used in a relatively arbitrary way in \mEdhoc{}
(see Section~\ref{sec:errorHandling}).
%
We now elaborate on some considerations that the application developers need to
take into account.
%

As in the IKEv2 DDoS analysis by~\cite{rfc8019}, the responder in \mEdhoc{}
is more vulnerable than the initiator.
%
The key similarity is that the initiator enjoys identity protection in the
first message.
%
None of the elements in the first \mEdhoc{} message can be proved by the
responder to be invalid, as long as the format is correct and the chosen
elliptic curve points lie on the chosen curve.
%
Additionally, execution may require the responder to obtain and verify
certificate chains.
%
For example, the content of the \mADone{} information element may need the
responder to take further action.
%
Since \mEdhoc{} is designed for constrained devices, this asymmetry needs to be
considered even more carefully than for IKEv2~\cite{rfc8019}.
%

The asymmetry between the adversary's effort towards the first message and that
of the responder may hence be significant and the possibility for applications
to select which entity acts as initiator and which acts as responder may
important.
%
\mEdhoc{} is profiled to work in conjunction with \mCoap{} and
\mOscore{}~\cite{ietf-core-oscore-edhoc-03}.
%
The profiling locks the \mEdhoc{} initiator role to the \mCoap{} client role and
hence reduces the possibilities to change the \mEdhoc{} roles according to DoS
vulnerability preferences.
%

Reflection attacks are another risk.
%
These are attacks where an adversary spoofs the source address of a victim in a
message and thereby tricks the responder into sending a message to the victim.
%
\mEdhoc{} suggests using a return path reachability method similar to IKEv2.
%
Note that even such reachability mechanisms can easily be used to make a
responder send reachability requests to arbitrary addressable targets.
%
However, such mechanisms might require that unsolicited reachability 
requests be
discarded, limiting the effects of anonymous DoS attacks.
%
In situations where the responder does not need to perform additional
communications to verify certificates etc, a reachability mechanism may be more
expensive in terms of time and storage compared to continuing with the protocol
while keeping a half-open state for a period of time.
%
However, if round-trip times are large, and half-open states hence are kept by
the receiver for a long time, a reachability mechanism can trade communication
for storage.
%

\mEdhoc{} responders querying external servers for certificate revocation checks
or lookups may cause systems-level issues if many distributed \mEdhoc{}
responders frequently queries such servers when DoSed by clients.
%

An adversary may also send forged error messages (see
Section~\ref{sec:errorHandling}), and specifically reject proposed ciphersuites.
%
The \mEdhoc{} \mSpec{} recommends the initiator to not try that ciphersuite with
the responder again in a new session.
%
If the adversary rejects all options for an initiator this way, it can prevent
communication between the initiator and that responder until the initiator's
cache is cleared.
%
Potentially, an adversary could lock a party of a group out of communication
altogether this way.
%

%------------------------------------------------------------------------- sub
\subsection{Unclear Security Model}
In addition to unclear contexts in which
\mEdhoc{} can be used, the \mSpec{} also does not provide enough detail about
adversary capabilities.
%
The four different cryptographic cores included in \mEdhoc{} are based on
academic protocols which are designed to work with highly specific but
potentially different adversary models.
%
%For example, \mOptls{}, which essentially has the same core as \mStat{}, is
%shown to be secure in the CK model~\cite{DBLP:conf/crypto/CanettiK02}, which
%explicitly separates long-term key storage from that of the ephemeral keys and
%session state.
%%
%This fits in well with our use of TEEs.
Since \mSigma{} cannot protect against compromised ephemeral keys, the authors
of \mEdhoc{} felt that considering the compromise of ephemeral keys separately
from that of long-term keys was not required~\cite{personalCommunication}.
%
The reason was presumably based on the fact that the \mSigSig{} method was
modeled closely on the \mSigmaI{} variant of \mSigma{}, and that it would be
preferable to obtain a homogeneous security level among the \mEdhoc{}
methods.~\cite{Norr21}
%
However, this only holds true for situations where one is only interested in the
session key confidentiality for an ongoing session.
%
Secure modules, in addition to being able to store long-term keys, are useful in
other ways too.
%
They also provide weak Post-Compromise Security (PCS) guarantees as discussed
above.
%
Upon discussion with the authors, they included recommendations on storing
long-term keys, and how to perform operations on these keys inside a secure
module.
%

%-------------------------------------------------------------------------- sub
\subsection{Session Key Material}
\label{sec:sessionKeyMaterial}
As we have seen, \mEdhoc{} establishes some
session-key material, which can be fed into the \mEdhoc{}-Exporter to derive
session keys.
%
This key material is directly influenced by \mGxy{} and a party's secret static
long-term key, if they use \mStat{}.
%
As mentioned earlier, mutual explicit injective agreement cannot be obtained for
$P_{I}$.
%
This might prove to be a problem, and we proposed three potential alternatives
for addressing this to the \mEdhoc{} authors.
%
\begin{itemize}
    \item Include \mIdcredi{} or a hash thereof in the first and
    second messages:
%
    This increases message size and also leaks the initiator's identity.
%
    \item Derive session-key material without using $P_{I}$:
%
    This deviates from the structure of protocols like \mOptls{} from which the
    \mStat{}-based methods draw heavy inspiration.
%
    In those protocols, including $P_{I}$ while computing session-key
    material is crucial to obtaining resistance against the compromise of the
    initiator's ephemeral key.
%
    \item Include a fourth message from the
    responder to the initiator which contains a MAC based on information
    obtained using $P_{I}$:
\end{itemize}
%
While the last option increases the number of messages in the protocol, the
\mEdhoc{} authors decided to go with this option for situations where it is
necessary to provide explicit injective agreement on $P_{I}$.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Conclusions and Future Work}}
\label{sec:conclusion}
As part of this paper, we modeled all four authentication methods of the
\mEdhoc{} protocol using the \mTamarin{} verification tool.
%
We used a server with 2 Intel(R) Xeon(R) Gold 6242 CPU @ 2.80GHz, which had a
total of 32 cores / 64 threads, and of the total 384GiB, the server allotted
256GiB of memory for the \mTamarin{} job.
%
We report both the time taken to complete the task (``real time'') and the CPU
time spent on the task (``user time'').
%
Time measurements are rounded to the nearest second.
%
We formulated and verified the following properties in a precise adversary model
with controlled access to TEEs and a precise modeling of \mXor.
%
\begin{itemize}
\item Injective agreement for both $I$ and $R$
\item Implicit agreement for both $I$ and $R$
\item Perfect Forward Secrecy (PFS) for the session-key material
\item Weak post-compromise security for the session-key material
\item Secrecy and integrity of \mADthree{}
\end{itemize}
%
We consider two separate sets of parameters, a partial set ($S_P$) and the full
set ($S_F$).
%
The set $S_P$ consists of the following pieces of information: the identity of
the responder, roles, context identifiers \mCi{} and \mCr, cipher suites
\mSuites, and session-key material excluding $P_I$.
%
For injective agreement, when the initiator uses a \mStat{} method, they are
ensured agreement only on this above set of parameters.
%
The set $S_F$ is the set $S_P$ along with the initiator's identity and $P_I$.
%
The responder is guaranteed injective agreement on the parameters $S_F$,
irrespective of what method they run, while the initiator is guaranteed
injective agreement on $S_F$ as long as they run a \mSig{} method.
%
Implicit agreement can be reached for both parties on the set $S_F$.
%
In addition, mutual entity authentication, UKS- and KCI-resistance can be
inferred from the verified properties.
%
We present the results in Table~\ref{tab:props}.
%

Mutual entity authentication, UKS- and KCI-resistance can be inferred
from the verified properties.
%

\begin{table*}[t]
        \centering
          \resizebox{\textwidth}{!}{%
            \begin{tabular}{|l|c|c|c|c|}
            \hline
              \textbf{Lemma $\backslash$ Method} & \textbf{SIG-SIG} & 
\textbf{SIG-STAT} & \textbf{STAT-SIG} & \textbf{STAT-STAT}\\
              \hline
              \textbf{Injective agreement / I} & $S_F$ & $S_F$ & $S_P\ddagger$ & 
$S_P\ddagger$\\
              \textbf{Injective agreement / R} & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
              \textbf{Time (real/user)} & 3m10.782s / 76m23.828s & 52m57.153s / 1909m1.455s$\dagger$ & 
              5m32.432s / 139m36.018s & 30m54.891s / 848m36.833s \\
              \textbf{Implicit agreement / I} & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
              \textbf{Implicit agreement / R} & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
              \textbf{Time (real/user)} & 3m34.222s / 89m41.770s & 6m46.187s / 180m6.615s 
& 10m34.228s / 253m22.845s & 1m32.187s / 67m2.723s $\dagger$\\
              \textbf{Session key secrecy} & \cm & \cm & \cm & \cm\\
              \textbf{Time (real/user)} & 1m23.317s / 52m16.347s & 3m54.009s / 155m54.834s & 12m33.884s / 457m32.698s & 20m40.391s / 915m15.590s\\
              \textbf{Secrecy of AD3} & \cm & \cm & \cm & \cm\\
              \textbf{Integrity of AD3} & \cm & \cm & \cm & \cm\\
              \textbf{Time (real/user)} & 2m39.727s / 101m2.371s & 5m51.728s / 223m59.728s & 
              5m51.728s / 223m59.728s & 46m0.643s / 1786m3.825s\\
			\hline
            \end{tabular}}\\[1em]
          \caption{Verified properties. $S_P$ contains roles,
            responder identity, session-key material (excluding
            $P_I$), \mCi, \mCr, and \mSuites. $S_F$ is $S_{P}$,
            the initiator identity, and $P_I$.\\
            $\dagger$: For SIG-STAT and STAT-STAT implicit
            authentication using the full XOR model the verification
            had to be abandoned at 14246m43s and 2057m47s of computation time,
            respectively. The time reported is for verification under
            the simplified XOR modeling of message 2.\\
            $\ddagger$: When the initiator is using STAT mode we
            cannot get explicit agreement on the intiator's own key
            material, therefore in these two cases we check injective
            agreement for all key material except $P_I$.\\
          }
\label{tab:props}
\end{table*}

Further, we identified a situation where initiators may establish an \mOscore{}
security context with a different party than the application using \mEdhoc{}
intended, and proposed a simple mitigation.
%
We discussed how the IETF may extract and better define security properties
to enable easier verification.
%
We also discussed some aspects of the protocol with respect to error handling
and denial of service attacks.
%

We verified each method in isolation, and leave as future work to verify whether
the methods are secure under composition.

\subsection{A Note About the Version of \mEdhoc}
\label{sec:newdrafts}
In this work, we have analyzed the \mEdhoc{} specification as of July
2020~\cite{our-analysis-selander-lake-edhoc-00}.
%
While our formal analysis applies to v5 of the \mSpec{} (February 2021),
there are newer versions.
%
The latest version at the time of writing is
v15 (July 2022)~\cite{draft-ietf-lake-edhoc-15}, which, among other things,
differ from v5 in terms of some inputs to the key derivations.
%
Modeling the new key derivation function would have needed sweeping changes
across our entire formal model, and due to paucity of time, we could not modify
the \mTamarin{} model to be up to date with the current version.
%
However, we do refer to various aspects
(error handling, denial of service etc) of this latest version,
in Sections~\ref{sec:errorHandling} and \ref{sec:discussion}.
%
Modeling the latest version of the protocol is also left as future work.
%

%-------------------------------------------------------------------------- ack
\section*{ACKNOWLEDGEMENTS}
This work was partially supported by
the Wallenberg AI, Autonomous Systems and Software Program (WASP) 
funded by
the Knut and Alice Wallenberg Foundation.
%
We are grateful to G\"oran Selander, John Mattsson and Francesca Palombini 
for
clarifications regarding the specification.
%

%-------------------------------------------------------------------------- bib
\bibliographystyle{apalike}
{\small
    \bibliography{refComp}
}
\end{document}
