% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}

\usepackage[scaled=0.8]{helvet}    % Less huge \textsf{functionName}
\usepackage[misc,geometry]{ifsym} % for letter symbol
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usetikzlibrary{trees,snakes,arrows}
\usetikzlibrary{shapes,chains}
\usetikzlibrary{positioning}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}
\usepackage[nospace]{cite}

\input{macros}

\title{Formal Analysis of EDHOC Key Establishment for Constrained IoT Devices}
\author{
        Karl Norrman and 
        Vaishnavi Sundararajan and
        Alessandro Bruni
}

\begin{document}
\maketitle
%
\begin{abstract}
Given how common IoT devices that use constrained resources are becoming today, the need of the hour is communication protocols which can operate securely under such limitations.
%
For a few years, the Internet Engineering Task Force (IETF) has been working to standardize \mEdhoc{}, an authenticated key establishment protocol for such constrained IoT devices.
%
The first version of \mEdhoc{} was proposed in 2016.
%
In 2018, Bruni et al~\cite{DBLP:conf/secsr/BruniJPS18} used the \mProverif{} tool~\cite{DBLP:conf/csfw/Blanchet01} to formally analyze an early version of \mEdhoc{}, which had only two key establishment methods.  
%
%By now, the protocol has been fleshed out much more, and has been augmented with multiple new key establishment methods.
By 2021, the protocol had been fleshed out much more, with multiple new key establishment methods, and this version was formally analyzed using the \mTamarin{} prover~\cite{DBLP:conf/cav/MeierSCB13} in~\cite{Norr21}.
%
Here, we build on this work, and use \mTamarin{} to formally analyze the key establishment methods in the current version of \mEdhoc{}, as well as discuss some ramifications of the choices made while designing the protocol.
\vnote{We need to see what more we can say here, about the new stuff we're potentially adding}
\end{abstract}
%
%-------------------------------------------------------------------------- sec
\section{\uppercase{Introduction}}
\label{sec:introduction}
\input{intro}

%-------------------------------------------------------------------------- sec
\section{\uppercase{The \mEdhoc{} Protocol}}
\label{sec:edhoc}
\input{protocol}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Formalization and Results}}
\label{sec:formalization}
\input{formalization}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Trusted Execution Environments}}
\label{sec:TEE}
The main purpose of Trusted Execution Environments (TEE) is to prevent an
adversary with physical access to a device from accessing the computational
circuits.
%
They come in various forms of differing complexity.
%
Some, like ARM Trust Zone and Intel SGX are general purpose execution
environments, which are flexibly programmable.
%
Other, like the Universal Subscriber Identity Modules (USIM) used for
authentication to 3GPP mobile networks, have application specific interfaces for
authentication and key agreement protocols etc.
%
A key aspect is how much of the application is placed in the TEE and how much is
outside.
%

For larger devices that include general purpose processors with Trust Zone or
SGX, entire \mEdhoc{} and \mOscore{} may reside inside the TEE.
%
For constrained IoT devices in the lower end of the scale, a TEE may have to be
implemented using a special-purpose integrated circuit.
%
In the latter case, it may be beneficial to follow a minimalistic approach, and
contain the long-term key and only
the operations that need access to it in the TEE for cost reasons.
%

It may at first appear more secure to implement as much as possible inside the
TEE, but there is a security trade-off: the more code inside the TEE,
the higher the risk of implementation errors in the security-critical code.
%
Because the security critical code runs in the area where the long-term keys
reside, an implementation error here risks leaking information of the key to the
adversary.
%
From this perspective, it may be beneficial to follow the minimalistic approach
even when having access to Trust Zone or SGX.
%

A slightly more secure division of functionality is to also keep the
session key inside
the TEE and extend the interface to accept messages and return the
(en/de)crypted counter part.
%
That is, the interface exposes \mAead{} functions in the interface.
%

%-------------------------------------------------------------------------- sub
\subsection{Practical Aspects and Use Case}
\label{sec:TEE:useCase}
Authentication of a specific IoT device assumes that this devices is the only
entity with access to the long-term key associated with the corresponding
identity.
%
Since IoT devices may be accessible to adversaries, e.g., an insider cloning a
key card, the long-term keys must be appropriately protected.
%
A state of the art approach is to use a Trusted Execution Environment (TEE),
which holds the key and provides an API for operations using the key.
%
This is the approach taken by the
Trust-Zone based \mMuEdhoc{}~\cite{DBLP:conf/codaspy/Hristozov0XFLS21}
implementation for example.
%
Typical operations include signatures using the long-term private key of a
party.
%

%-------------------------------------------------------------------------- sub
\subsection{System and Adversary Model Extensions Supporting TEE}
\label{sec:TEE:advModel}
%
We extend the adversary model of~\cite{Norr21} by allowing the adversary
access to a TEE interface on a party of their choosing before and after the
\mEdhoc{} session.
%
This allows us to distinguish between a full compromise and a weak one, using
the terminology of~\cite{DBLP:conf/csfw/Cohn-GordonCG16}.
%
A weak compromise is when the adversary have temporary access to the TEE.
%
Seen in the framework of~\cite{DBLP:conf/icics/XuZRWTZ20}, we add adversary
capabilities corresponding to a server adversary, i.e., an adversary that
compromises a party, learns its ephemeral keys and may temporarily access its
TEE, but does not learn the party's long-term key.
%
The model of~\cite{Norr21} only captures server adversary capabilities without
access to the TEE, via the leakage of ephemeral keys, and local adversary
capabilities, or more specifically, a secure-world adversary with read-write
access to the
secure world where the long-term keys reside via the leakage of long-term keys.
%
Our extension allows analysis of so-called weak post-compromise security
(PCS)~\cite{DBLP:conf/csfw/Cohn-GordonCG16}.
%

We split the \mEdhoc{} functionality as follows.
%
The TEE contains the long-term key and allows the non-TEE parts of the
application to perform the operations on it via its interface.
%
More precisely, parties using the \mSig{} authentication method use a TEE with
an interface which accepts a message and returns the signature of that message
using the party's private long-term key.
%
A party $U$ using the \mStat{} authentication method use a TEE with an interface
accepting a point $P$ on the curve and returning $\mDH(P,\ \mGu{})$.
%
\knote{It should accept any value. Adversary may not stick to elements of the
    form $g^x$. Or we explicitly state that the TEE checks that the received
input lies on the curve (but this may not be sufficient: are the curves cyclic
groups? Need to check).}
%
The non-TEE parts implement \mEdhoc{} using this interface.
%
This interface requires the least functionality from the TEE, reducing the TEE's
complexity and possibly cost of its implementation.
%
The functional split is suitable even for the situation where a
constrained device has implemented only the storage of the long-term key in a
special purpose circuit with minimal processing functionality.
%
Since \mEdhoc{} focuses on constrained IoT devices, it seems appropriate to
cater for this setting.
%

%-------------------------------------------------------------------------- sub
\subsection{Extended Formalism and Security Properties}
\label{sec:TEE:fmAndProps}
Formally, we model the TEE interface by adding two new rewrite rules:
%
\begin{small}
\begin{verbatim}
rule forge_SIG:
   [!LTK_SIG($A, ~ltk), In(xx)] --[TEE($A)]-> [Out(sign(xx, ~ltk))]

rule exp_STAT:
   [!LTK_STAT($A, ~ltk), In('g'^~xx)] --[TEE($A)]-> [Out(('g'^~xx)^~ltk)]
\end{verbatim}
\end{small}
%
These rules allow the adversary to obtain terms representing signatures on a
value of their choice to forge signatures (\verb|forge_SIG|), or to obtain terms
representing a curve point of their choice raised to the power of the
long-term key (\verb|exp_STAT|).
%

Because it is a trivial attack when the adversary access these rules with values
from the test session, we must disqualify those rule applications.
%
We do so by creating an action fact \verb|TEE($A)|, where \verb|$A| is the
identity corresponding to the private key used, and then augmenting the
properties with a condition that no such action fact exists from the start of
the protocol execution and its end.
%
Care must be taken when specifying the start and the end.
%
Specifically, the start and end of the protocol run must be viewed w.r.t. the
role.
%
For example, the injective agreement property for the initiator in
the \mSigSig{} method requires that the adversary does not have access to the
TEE of the
responder from the time of transmission of the first message until the second
message is received by the initiator.
%
Because reception of one message and transmission of the next one at a party
is an atomic operation, these timepoints represent the start and end of the
protocol run from the perspective of the initiator.
%

We did not manage to get Tamarin to terminate for all lemmas and all methods
with the added TEE extension.
%
When the responder uses the \mStat{} authentication method Tamarin did not
complete the in a reasonable time for the authentication lemmas.
%
To combat this, we simplified the modeling of XOR encryption of the second
message for these lemmas when the responder uses \mStat{} authentication.
%
More precisely, the second message contains the two values \verb|R| (the
responder's identity) and
\verb|authR| (the authentication information), and we generally model the
XOR encryption by xoring each of them with their own key-stream terms.
%
For the problematic lemmas however, we resorted to xoring the entire tuple
\verb|<R, authR>| with a single key-stream term.
%
Given that no attacks were identified using our original modeling, this
simplification is intuitively not a severe restriction.
%
However, it is possible that we now miss attacks on these methods
combining properties of the two-term XOR encryption with TEE capabilities.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Error handling}}
\label{sec:errorHandling}
Section 6 of the current \mEdhoc{} specification~\cite{draft-ietf-lake-edhoc-15} states that error messages can be sent at any time and by any party.
%
There are three types of error messages: type 0 is used to represent success, type 1 represents a generic error message used for debugging purposes, and type 2 represents the failure to negotiate a common ciphersuite. 
%
Type 2 messages carry a list of supported ciphersuites by the responder.
%
The contents and semantics of type 1 messages are dependent on the implementation.
%
Consequently, type 1 error messages provide a generic message passing mechanism, albeit without a predefined semantics.
%
We now discuss some issues with this specification of error messages.

\subsection{Lack of connection identifiers}
Error messages do not include the optional connection identifiers \mCi{} or \mCr{}.
%
This is potentially problematic for connection-less transport layers, where these identifiers may be used to correlate messages.

\subsection{Improper handling}
\mEdhoc{} provides an error message mechanism, but little to no guidance on how it should be used safely.
%
For example, assume that an application using \mEdhoc{} logs error messages on a finite log with rotation.
%
If the log is used for anomaly detection or detection of sensitive events, then an adversary can simply inject error messages and fill the log until the sensitive event is overwritten.
%
In such situations, implementors should do proper log-separation and log management.

\subsection{Unspecified semantics for debugging messages}
Section 6.2 gives an example of sending a type 1 error message with the information string "Method not supported".
%
Note that \mEdhoc{} does not include a mechanism to support the negotiating of the connection method.
%
The initiator selects the method as part of the first message, and if the responder replies with a type 1 error message along with the information string "Method not supported", the standard does not tell an implementation how to act upon this information string for negotiation purposes.
%
An adversary can fake an error message, and there is no algorithm that is specified to ensure that a common available authentication mechanism is always selected.
%
In particular, note that Section 5.1 in the specification states that if processing fails for some reason, then "typically" an error message is sent, processing is terminated and protocol state is discarded. 
%
But negotiation needs us to remember state.

With respect to ciphersuite negotiation, Section 5.2.2 of the specification also states ``The Initiator MUST NOT change the supported cipher suites and
the order of preference in SUITES\_I based on previous error messages.'' 
%
However, \mSuites is sent in the clear, and therefore can be modified by the adversary.
%
It is important to consider what happens if the order of preference in \mSuites is changed either by the adversary, or by the initiator themselves for some other reason.
%
It might be helpful to include a flag in \mMsgone to indicate to the responder that a (modified) ciphersuite ordering depends on that from a previous execution.

%-------------------------------------------------------------------------- sec
\section{\uppercase{Improvements to the specification}}
\label{sec:discussion}
The \mEdhoc{} \mSpec{} has many points where it can be improved. 
%
We discovered a few of these issues in~\cite{Norr21}, but in this work, we also discuss a couple of new issues.
%
We communicated the points discussed in~\cite{Norr21} to the authors of the \mSpec{}.
%
Here we also list the protocol developers' response to being told of these ambiguities in the \mSpec{}.

%-------------------------------------------------------------------------- sub
\subsection{Unclear Intended Use}
\label{sec:unclearProtocolUse}
%
There are several security goals listed in the \mSpec{}.
%
However, these goals are informal, and imprecisely specified, and the lack of intended usage makes them difficult to interpret as well.
%
Since we have no indication about the use cases in which \mEdhoc{} can be employed, it becomes tough to evaluate if the listed security goals are the ones that we need the protocol to satisfy.

The overarching goal of \mEdhoc{} is to establish a security context for \mOscore{} using as few roundtrips and as small messages as possible, which dictates the design of the protocol.
%
However, \mEdhoc{} might be intended for multiple use cases, some of which might not even be covered in the \mSpec{}, which might need different guarantees from the ones mentioned therein.
%
In order to identify security goals that might apply to multiple such cases, we made up some user stories corresponding to typical use cases, which helped us identify some subtle points of concern in \mEdhoc.
%
We communicated these issues to the authors of \mEdhoc{}.
%
\vnote{Add responses from the developers to these questions}

\subsubsection{Non-Repudiation:}
Access control mechanisms can vary depending on what the underlying application is.
%
A nuclear power-plant might need to keep track of who enters and leaves, but a coffee machine that logs every user and their coffee preference might lead to a privacy concern.
%
This thought experiment allowed us to perceive that the \mEdhoc{} \mSpec{} did not even consider non-repudiation.
%
When we pointed this out to the authors of the \mSpec, they recognized this concern, and added a discussion about how the various \mEdhoc{} methods satisfy (or not) non-repudiation.

\subsubsection{Unintended Peer Authentication: }
In Section~3.2 in the \mSpec{}, the authors state that parties executing \mEdhoc{} must be configured such that they only run \mEdhoc{} with a restricted (according to some reasonable policy) set of peers.
%
However, \mIdcredr{} in the second message is sent in the clear, and can therefore lead to some masquerade attacks by the adversary.
%

Suppose a person configures the restriction policy such that every device in their home is allowed to set up an \mEdhoc{} session with any other device in the home.
%
However, the adversary has managed to gain control of one of these devices (say $A$).
%
Device $A$ is part of the allowed group of devices, so $B$ will accept an \mEdhoc{} run with $A$, even though $A$ is now compromised.
%
In addition, since $B$ does not explicitly check to see if the \mIdcredr{} received in the second message corresponds to the intended identity, it leads to attacks where $B$ wants to talk to another non-compromised home device $C$, but $A$ responds in place of $C$ and $B$ continues with the run anyway.
%
This requires the initiator to match \mIdcredr{} to the identity intended by them when they send out the first message.
%
We included this check in our model.
%
We communicated this to the authors of \mEdhoc{}.
\vnote{And what did they do about it?}

\subsubsection{Denial of Service: }
Denial of Service (DoS) attacks for IoT protocols are very well-studied.
%
But DoS is not well documented for \mEdhoc{} in particular, since it delegates DoS handling to the application.
%
The \mSpec{} does not include any specific measures for countering such attacks.

Section 8.7 of the \mEdhoc{} specification~\footnote{draft-ietf-lake-edhoc-14} gives two recommendations for countering DoS attacks.
\vnote{Is this the latest spec? The spec we’re analyzing? Which one?}
%
First, \mEdhoc{} relies on lower layers to mitigate DoS, and an example of DoS countermeasures is given: checking the return address upon receipt of the first message.
%
Second, an application may try to determine (in some way) that a seemingly valid message is in fact probably a forgery and should be ignored or cause the protocol to abort.

No recommendation is given on how to minimize DoS effects stemming from the use of error messages, which can be used in a relatively arbitrary way in \mEdhoc{} (see Section~\ref{sec:errorHandling}).
%
We now elaborate on some considerations that the application developers needs to take into account.
%

As in the IKEv2 DDoS analysis by~\cite{rfc8019}, the responder is more vulnerable than the initiator.
%
The key similarity is that the initiator is allowed identity protection in the first message.
%
None of the elements in the first \mEdhoc{} message can be proved by the responder to be illegal, as long as the format is correct and the chosen elliptic curve points lie on the pre-chosen curve.
%
Additionally, execution may require the responder to obtain and verify certificate chains.
%
For example, the content of the \mADone{} information element may need the responder to take further action.
%

The asymmetry between the adversary's effort towards the first message and that of the responder may hence be significant.
%
Note that since \mEdhoc{} is to be used in conjunction with \mCoap{} and \mOscore{}, either party executing the \mCoap{} protocol might be the one playing the initiator role in \mEdhoc.
%
Since \mEdhoc{} is designed for constrained devices, this asymmetry needs to be considered even more carefully than for IKEv2~\cite{rfc8019}.


Reflection attacks are another possibility.
%
These are attacks where an adversary spoofs the source address of a victim in a message and thereby tricks the responder into sending a message to the victim.
%
\mEdhoc{} suggests using a return path reachability method similar to IKEv2.
%
Note that even such reachability mechanisms can easily be used to make a responder send reachability requests to arbitrary addressable targets.
%
However, such mechanisms might require that unsolicited reachability requests be discarded, limiting the effects of
anonymous DoS attacks.
%
In situations where the responder does not need to perform additional communications to verify certificates etc, a reachability mechanism may be more expensive in terms of time and storage compared to continuing with the protocol while keeping a ``half-open’’ state for a period of time.
%
The latter may cause a systems-level issue if many distributed \mEdhoc{} responders frequently request such servers.
%
However, if round-trip times are large, and half-open states hence are kept by the receiver for a long time, a reachability mechanism can trade communication for storage.

An adversary may also send forged error messages (see Section~\ref{sec:errorHandling}), and specifically reject proposed ciphersuites.
%
It is recommended for the initiator to not try that ciphersuite with the responder again in a new session.
%
If the adversary rejects all options for a initiator this way, it can prevent
communication between the initiator and that responder until the cache is
cleared.
%
Potentially, an adversary could lock a party of a group out of communication altogether this way.
%

%------------------------------------------------------------------------- sub
\subsection{Unclear Security Model}
In addition to unclear contexts in which \mEdhoc{} can be used, the \mSpec{} also does not provide enough detail about adversary capabilities. 
%
The four different cryptographic cores included in \mEdhoc{} are based on academic protocols which are designed to work with highly specific but potentially different adversary models.
%
%For example, \mOptls{}, which essentially has the same core as \mStat{}, is shown to be secure in the CK model~\cite{DBLP:conf/crypto/CanettiK02}, which explicitly separates long-term key storage from that of the ephemeral keys and session state.
%%
%This fits in well with our use of TEEs.
Since \mSigma{} cannot protect against compromised ephemeral keys, the authors of \mEdhoc{} felt that considering the compromise of ephemeral keys separately from that of long-term keys was not required~\cite{personalCommunication}.
%
The reason was presumably based on the fact that the \mSigSig{} method was modeled closely on the \mSigmaI{} variant of \mSigma{}, and that it would be preferable to obtain a homogeneous security level among the \mEdhoc{}
methods.~\cite{Norr21}
%
However, this only holds true for situations where one is only interested in the session key confidentiality for an ongoing session.
%
Secure modules, in addition to being able to store long-term keys, are useful in other ways too. 
%
They also provide Post-Compromise Security (PCS) guarantees, for example.
%
Upon discussion with the authors, they included recommendations on how to store long-term keys, and how to perform operations on these keys inside a secure module.
\vnote{This needs more description?}
%-------------------------------------------------------------------------- sub
\subsection{Session Key Material}
\label{sec:sessionKeyMaterial}
As we have seen, \mEdhoc{} establishes some session key material, which can be fed into the \mEdhoc{}-Exporter to derive session keys.
%
This key material is directly influenced by \mGxy{} and a party's secret static long-term key, if they use \mStat{}.
%
As mentioned earlier, mutual explicit injective agreement cannot be obtained for $P_{I}$.
%
This might prove to be a problem, and we propose three potential alternatives for addressing this.
%
\begin{itemize}
\item Include \mIdcredi{} or a hash thereof in the first and second messages: 
%
This increases message size and also leaks the initiator's identity.
\item Derive session key material without using $P_{I}$: 
%
This deviates from the structure of protocols like \mOptls{} from which the \mStat{}-based methods draw heavy inspiration.
%
In those protocols, $P_{I}$'s presence in the computation of session key material is crucial to obtaining resistance against the compromise of the initiator's ephemeral key.
\item Include a fourth message from the responder to the initiator which contains a MAC based on information obtained using $P_{I}$:
%
While this option increases the number of messages in the protocol, the authors decided to go with this option for situations where it is necessary to provide explicit injective agreement on $P_{I}$.
\end{itemize}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Conclusions and Future Work}}
\label{sec:conclusions}
\label{sec:newdrafts}
We formally modeled all four
methods of the \mEdhoc{} \mSpec{} using \mTamarin.
%
We formulated several important security properties and identified precise
adversary models in which we verified these.
%
The properties are shown in Table~\ref{tab:props}.
%
Mutual injective agreement covers the parameters $S_P$:
responder identity, roles, session key material (except for $P_I$ when
initiator uses the \mStat{} authentication
method), context identifiers \mCi{} and \mCr, and cipher suites \mSuites.
%
The responder in addition is ensured agreement on the initiators identity and
$P_I$, i.e., on the set $S_F$.
%
Implicit agreement covers all previously mentioned parameters for both peers.
%
Verification of all lemmas, including model validation lemmas, took 42 minutes
on an Intel Core i7-6500U 2.5GHz using two cores.
%
Mutual entity authentication, UKS- and KCI resistance can be inferred
from the verified properties.
\knote{In Section 3.3 we say that injective agreement does \emph{not} hold for
    all methods. It is a little contradictory to the table below where we
    exclude $P_I$. It would be better to show it as not holding when $P_i$ is
    included (both for consistency and for clarity).
}
%
\begin{table*}[h!]
        \centering
        \caption{Verified properties. $S_P$ contains
            roles, responder identity, session key material (excluding
            $P_I$), \mCi, \mCr, and \mSuites. $S_F$ is $S_{P}$,
            the initiator identity, and $P_I$.}
        \label{tab:props}
        \begin{tabular}{|l|c|c|c|c|}
                \hline
                & \mSigSig & \mSigStat & \mStatSig & \mStatStat \\
                \hline
                Injective agreement for I & $S_F$ & $S_F$ & $S_P$ & $S_P$\\
                Injective agreement for R & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                Implicit agreement for I & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                Implicit agreement for R & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                PFS for session key material & \cm & \cm & \cm & \cm\\
                \hline
        \end{tabular}
\end{table*}
\knote{This should be extended with verification times and with TEE.
    It should also show that when responder uses \mStat{} and \mSig{}, a
    different XOR encryption is used.
}

Further, we identified a situation where initiators may establish an \mOscore{}
security context with a different party than the application using \mEdhoc{}
intended, and proposed a simple mitigation.
%
We discussed how the IETF may extract and better define security properties to
enable easier verification.

We verified each method in isolation, and leave as future work to verify whether
the methods are secure under composition.

%\subsection{Newer Versions of the Specification}
%\label{sec:newdrafts}
In this work, we have analyzed the \mEdhoc{} version as of July
2020~\cite{our-analysis-selander-lake-edhoc-00}.
%
There are newer versions, with the most recent version as
of February 2021~\cite{latest-ietf-lake-edhoc-05}.
%
However, the changes to the protocol over these versions are not
particularly significant for our analysis.
%

%-------------------------------------------------------------------------- ack
\section*{ACKNOWLEDGEMENTS}
This work was partially supported by
the Wallenberg AI, Autonomous Systems and Software Program (WASP) funded by
the Knut and Alice Wallenberg Foundation.
%
We are grateful to G\"oran Selander, John Mattsson and Francesca Palombini for
clarifications regarding the specification.
%

%-------------------------------------------------------------------------- bib
\bibliographystyle{apalike}
{\small
    \bibliography{refComp}
}
\end{document}
