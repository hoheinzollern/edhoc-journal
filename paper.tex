% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}

\usepackage[scaled=0.8]{helvet}    % Less huge \textsf{functionName}
\usepackage[misc,geometry]{ifsym} % for letter symbol
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usetikzlibrary{trees,snakes,arrows}
\usetikzlibrary{shapes,chains}
\usetikzlibrary{positioning}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}
\usepackage[nospace]{cite}

\input{macros}

\title{Formal Analysis of EDHOC Key Establishment for Constrained IoT Devices}
\author{
        Karl Norrman and 
        Vaishnavi Sundararajan and
        Alessandro Bruni
}

\begin{document}
\maketitle
%
\begin{abstract}
Given how common IoT devices that use constrained resources are becoming today, the need of the hour is communication protocols which can operate securely under such limitations.
%
For a few years, the Internet Engineering Task Force (IETF) has been working to standardize \mEdhoc{}, an authenticated key establishment protocol for such constrained IoT devices.
%
The first version of \mEdhoc{} was proposed in 2016.
%
In 2018, Bruni et al~\cite{DBLP:conf/secsr/BruniJPS18} used the \mProverif{} tool~\cite{DBLP:conf/csfw/Blanchet01} to formally analyze an early version of \mEdhoc{}, which had only two key establishment methods.  
%
%By now, the protocol has been fleshed out much more, and has been augmented with multiple new key establishment methods.
By 2021, the protocol had been fleshed out much more, with multiple new key establishment methods, and this version was formally analyzed using the \mTamarin{} prover~\cite{DBLP:conf/cav/MeierSCB13} in~\cite{Norr21}.
%
Here, we build on this work, and use \mTamarin{} to formally analyze the key establishment methods in the current version of \mEdhoc{}, as well as discuss some ramifications of the choices made while designing the protocol.
\vnote{We need to see what more we can say here, about the new stuff we're potentially adding}
\end{abstract}
%
%-------------------------------------------------------------------------- sec
\section{\uppercase{Introduction}}
\label{sec:introduction}
\input{intro}

%-------------------------------------------------------------------------- sec
\section{\uppercase{The \mEdhoc{} Protocol}}
\label{sec:edhoc}
\input{protocol}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Formalization and Results}}
\label{sec:formalization}
\input{formalization}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Denial of Service}}
\label{sec:dos}

% There is little about EDHOC specific DoS stuff; that is interesting in itself,
% and motivates this section
There is a wealth of information about DoS in general, and more specifically for
IoT.
%
However, there is little information regarding DoS aspects stemming
specifically from \mEdhoc{}.
%

% Other protocols have DoS considerations, but EDHOC delegates it to developer
In contrast to \mTls{} and IKEv2,
the \mEdhoc{} core specification does not include any specific measures for
countering Denial of Service (DoS) attacks.
%
Instead, that responsibility is delegated to the application, using
proprietary measures or extensions to \mEdhoc{}.
%

% The core is small and probably not vulnerable to anything unexpected
The \mEdhoc{} core specification has limited functionality, few negotiable
parameters and processing rules.
%
Hence, we argue in this section that its attack surface
is limited from a DoS perspective.
%

% However, It is difficult to define what EDHOC *is*; it s partially specified in many
% specs
However, \mEdhoc{} leaves much of the semantics of its messages undefined or
specified as extensions.
%
Examples of mechanisms with mostly undefined semantics include processing
rules and content of error messages and of the additional data that is
passed in each of the \mEdhoc{} messages.
%
Another example is that the core specification does not include a
message transport mechanism.
%
The transport for \mEdhoc's primary target, i.e., to key \mOscore{},
is \mCoap{}.
%
This is specified in~\cite{ietf-core-oscore-edhoc-03}, but still leaves
many design choices to the application.
%
Because of this, it is difficult to draw the line between what is considered as
\mEdhoc{} and what is an extension.
%

% Pros with undefined semantics: flexibilty; Cons: developers can shoot
% themselves in the foot
Undefined semantics allow the implementors much freedom
and flexibility to design applications.
%
On the down-side, the few recommendations given increase the risk of
applications being vulnerable to DoS via \mEdhoc{}, even
though the core \mEdhoc{} specification itself is arguably not particularly
weak in this respect.
%

\paragraph{DoS mitigation is left to developers.}
Section 8.7 of the \mEdhoc{} specification\footnote{draft-ietf-lake-edhoc-14}
explains the design philosophy w.r.t.
DoS in two paragraphs and gives two recommendations.
%
The first being that \mEdhoc{} relies on lower layers to mitigate DoS, and an
example of DoS countermeasures is given: checking return routeability when
receiving the first message.
%
The second being that an application may try to determine (in some way) that an
apparently valid message is in fact probably a forgery and should be ignored or
cause processing to stop.
%

No recommendation is given on how to minimize DoS effects stemming from use of
error messages, which can be used in an arbitrary way in \mEdhoc{}
(see Section~\ref{sec:errorHandling} below).
%
While there is some work on DDoS aspects of \mCoap{}, and much on IoT in
general, this does not capture the particular consequences originating with
\mEdhoc{}.
%
We now elaborate on some considerations application developers needs to take
into account.
%


\paragraph{Amplification and role asymmetry.}
For the same reasons as given in the IKEv2 DDoS analysis
by~\cite{rfc8019} the responder is more vulnerable than the
initiator.
%
The key similarity between IKEv2 and \mEdhoc{} here is that the initiator is
anonymous in the first message and that creating the first message is
computationally cheap and requires no storage.
%
No element in the first \mEdhoc{} message can be verified by the receiver as
being legitimate as long as the format is correct and elliptic curve points
lie on the proposed curve.
%
\mEdhoc{} leave it to the application and its
transport layer to resolve any issues.
%
In addition to the computational resources the responder spends, \mEdhoc{}
execution may require the responder to
obtain and verify certificate chains, and verify
certificate-revocation servers as a result of the spoofed initial message.
%
For example, the content of the \mADone{} information element may hint the
responder to take further actions.
%

The asymmetry between the adversary's effort and the responder's may hence be
significant.
%
Since \mEdhoc{} specifically targets constrained devices this asymmetry needs to
be considered even more carefully than for IKEv2~\cite{rfc8019}.
%

Depending on the use case, the first \mEdhoc{} message may be sent by either
party in a session.
%
For example, even though it may seem intuitive that an electronic
key-card initiates the connection towards lock, the first \mEdhoc{} message
could be included in the response from the lock.
%
This means the lock can postpone heavy verification actions until it has
authenticated the key card after receiving the third \mEdhoc{} message.
%
The draft IETF specification profiling \mEdhoc{} for use with
\mCoap{} and \mOscore{} ~\cite{ietf-core-oscore-edhoc-03},
however, defines the
\mCoap{} client to be the \mEdhoc{} initiator, and hence reduces the flexibility
to use that option.
%

\paragraph{Reflection Attacks.}
Reflection attacks are attacks where an adversary spoofs the source address of a
victim in a message and thereby tricks the responder to send a message to the
victim.
%
\mEdhoc{} leaves protection against this to the transport protocol and
application, and suggests using a return path reachability method similar to IKEv2.
%
We note that such reachability mechanisms can easily be used to make a responder
send reachability requests to arbitrary addressable targets.
%
Depending on the design of such reachability mechanisms, they may require that
unsolicited reachability requests are discarded, limiting the effects of
anonymous DoS attacks like these.
%

In situations where the responder does not need to perform additional
communications to verify certificates or similar, a reachability mechanism may
be more expensive in terms of time and storage compared to continue with the
protocol and keeping a half-open state for a period of time.
%
Doing so would also avoid creating secondary DoS effects on certificate storage
nodes or certificate revocation servers.
%
The latter may cause a systems-level issue if many distributed
\mEdhoc{} responders frequently requests such servers.
%
However, if round-trip times are large, and half-open states hence are kept
by the receiver for a long time, a reachability mechanism can trade
communication for storage.
\footnote{RFC8019 discuss some numbers as examples of tradeoffs. Should we set
up a simple model and derive an expression for trade-offs? Could be useful for
implementors to consider, but low academic value. This would capture also
amplification.}
%

%\mPoint{In a constrained device randomness may be easily depleted}
%Assume an adversary generate (deterministic) bogus message 1s and send these at
%a sufficiently high rate to the responder.
%%
%\mEdhoc{} specifically targets constrained devices, that presumably may not
%always have good randomness sources.
%%
%Is it possible to deplete or significantly reduce the entropy of the source and
%in this way be able to predict the responder's random input to other sessions
%(with other initiators)?
%%
%The LAKE WG have been talking about effects of poor randomness on signatures, so
%this should be an issue, no?
%%

\mPoint{\mEdhoc{} can deadlock if not used correctly}

An adversary may send forged error messages, and specifically reject proposed
ciphersuites.
%
The initiator is recommended to not try that ciphersuite with the responder
again in a new session for a while.
%
If the adversary rejects all options for a initiator this way, it can prevent
communication between the initiator and that responder until the cache is
cleared.
%
Potentially, an adversary could lock a party of a group out of communication all
together this way.
%
This needs to be considered by applications.
%

While we have not conducted a formal analysis of the fact, the structure of all
methods are so similar that it seems plausible that none of them would be
stronger against DDoS than the others.
%

Implementers are well advised to consult \cite{rfc8019}, which provides much
good general information about DoS for key establishment
protocols with the 3-message structure employed by \mEdhoc{}.
%
However, ultimately, a product-specific risk assessment is required to
determine appropriate DDoS mitigations.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Error handling}}
\label{sec:errorHandling}
\mPoint{Error handling is undefined except for algo negotiation}
Section 6 of the \mEdhoc{} specification\footnote{draft-ietf-lake-edhoc-14}
states that error messages can be sent at any time and by any party.
%
One error message type is defined (for algorithm negotiation), and the rest can
be arbitrarily defined by the implementation.
%
The contents and semantics of these messages are also implementation defined.
%
Consequently, the error messages provide a generic message passing mechanism.
%

\textbf{Q:} Is there any situation where it makes sense that the initiator sends
a unsupported ciphersuite message instead of message 3?
%

\textbf{Q:} In Section H: if no message correlation support by the transport
layer, \mCi{} and \mCr{} should be used for correlation of messages to a
session.
%
Error messages do not carry \mCi{} or \mCr{}; will this create a problem?
%

\mEdhoc{} provides the error message mechanism, but gives little to no guidance
on how it should be used safely.
%
Example of issue with improper use: Assume application logs error messages a
finite log with log rotation.
%
If the log is used for anomaly detection or detection of sensitive events, then
an adversary can simply inject error messages and fill the log until the
sensitive event is overwritten.
%
If the filling error messages are less suspicious than the actual attack, this
may be beneficial for the adversary.
%
Implementors should do proper log-separation and log management.
%

Section 6.2 gives an example of sending an error message "method not
supported".
%
This message cannot be used to negotiate method securely.
%
The reason is that error messages are not integrity protected, and an initator
only proposes one method, and therefore the same tactic used for ciphersuite
negotiation cannot be used for methods.
%
Because method negotiation can be viewed in the context of crypto agility, there
is room for improvement.
%




%-------------------------------------------------------------------------- sub
\section{\uppercase{Discussion}}
\label{sec:discussion}
There are a few places where \mEdhoc{} can be improved,
which we found during this work and communicated to the authors.
%
We discuss them below.
%

%-------------------------------------------------------------------------- sub
\subsection{Unclear Intended Use}
\label{sec:unclearProtocolUse}
%
The \mEdhoc{} \mSpec{} lists several security goals, but they are
imprecise and difficult to interpret due to lack of context and intended usage
descriptions.
%
Without knowing how the protocol is to be used,
it is not clear whether the listed security goals are the most important ones
for constrained IoT devices.
%

The abstract goal of \mEdhoc{} is simple: establish an \mOscore{} security
context using few roundtrips and small messages.
%
From that, the design of \mEdhoc{} is mainly driven by what
can be achieved given the technical restrictions.
%
Focusing too much on what can be achieved within given restrictions, and paying
too little attention to the use cases where the
protocol is to be used and their specific goals, risks resulting in
sub-optimal trade-offs and design decisions.
%

\mEdhoc{} is intended to cover a variety of use cases, many of which are
difficult to predict today.
%
However, this does not
prevent collecting \emph{typical} use cases and user stories
to identify more specific security goals that will be important in most cases.
%

While constructing our model, we made up simple user stories to identify
security properties of interest.
%
Several of these revealed subtleties and undefined aspects of \mEdhoc{}.
%
We informed the \mEdhoc{} authors, who addressed these aspects in the
\mSpec{}.
%

\subsubsection{(Non-)Repudiation}
An access control solution for a nuclear power-plant may need to log who is
passing through a door, whereas it may be undesirable for, say, a coffee
machine to log a list of users along with their coffee preferences.
%
Via this simple thought experiment, we realized that the \mSpec{} did not
consider the concept of (non)-repudiation.
%
In response, the authors of the \mSpec{} added a paragraph discussing how
different methods relate to (non)-repudiation.

\subsubsection{Unintended Peer Authentication}
Section~3.2 of the \mSpec{} states that parties must be configured
with a policy restricting the set of peers they run \mEdhoc{} with.
%
However, the initiator is not required to verify that the \mIdcredr{} received
in the second message is the same as the one intended.
%
The following attack scenario is therefore possible.
%

Suppose someone has configured all devices in their home to be in the
allowed set of devices, but that one of the devices ($A$) is compromised.
%
If another device $B$, initiates a connection to a third device $C$, the
compromised device $A$ may interfere by responding in $C$'s place, blocking
the legitimate response from $C$.
%
Since $B$ does not verify that the identity indicated in the second message
matches the intended identity $C$, and device $A$ is part of the allowed set,
$B$ will complete and accept the \mEdhoc{} run with device $A$ instead of the
intended $C$.
%
The obvious solution is for the initiator to match \mIdcredr{} to the intended
identity indicated by the application, which we included in our model.
%
We have communicated this to the \mEdhoc{} authors and they are considering
how to resolve the issue.
%

%------------------------------------------------------------------------- sub
\subsection{Unclear Security Model}
We argue that the \mSpec{} gives too little information about what capabilities
an adversary is assumed to have, and that this leads to unclear design goals and
potentially sub-optimal design.
%

Even though \mEdhoc{} incorporates cryptographic cores from different academic
security protocols, its design does not take into account the adversary models
for which these protocols were designed.
%
For example, \mOptls{}, whose cryptographic core is essentially the same
as the \mStat{} authentication method, is designed to be secure in the CK
model~\cite{DBLP:conf/crypto/CanettiK02}.
%
The CK security model explicitly separates the secure storage of long-term
keys from storage of session state and ephemeral keys.
%
This is appropriate for modelling the use of secure modules.
%

The \mEdhoc{} authors indicated to us that it was
not necessary to consider compromised ephemeral keys separately from
compromised long-term keys.
%
The rationale is that \mSigma{} cannot protect against compromised ephemeral
keys~\cite{personalCommunication}.
%
That rationale is presumably based on the fact that the \mSigSig{} method is
closely modeled on the \mSigmaI{} variant of \mSigma{}, and that it would be
preferable to obtain a homogeneous security level among the \mEdhoc{}
methods.
%
That rationale is only true, however, if one restricts attention to session key
confidentiality of an ongoing session.
%
Secure modules provide value in other ways, for example, by allowing
constructions with Post-Compromise Security (PCS) guarantees.
%
We discussed this with the authors, and
the latest version of the \mSpec{}~\cite{latest-ietf-lake-edhoc-05} includes
recommendations on storage of long-term keys and operations on these inside a
secure module.
%

%-------------------------------------------------------------------------- sub
\subsection{Session Key Material}
\label{sec:sessionKeyMaterial}
\mEdhoc{} establishes session key material, from which session keys
can be derived using the \mEdhoc{}-Exporter.
%
The session key material is affected by \mGxy{}, and if a party uses the
\mStat{} authentication method, also by that party's secret static long-term key.
%
As shown in Section~\ref{sec:formalization}, mutual injective agreement cannot
be achieved for $P_I$.
%
If this property is not important for constrained IoT devices which cannot use
any of the other methods, then one can simply accept that the methods have
different authentication strengths.
%
Otherwise, this is a problem.
%

We identified three alternatives for resolving this.
%
One alternative is to include \mIdcredi{}, or its hash, in the first and
second messages.
%
This would, however, increase message sizes and prevent initiator identity
protection, which are grave concerns for \mEdhoc{}.
%
A second alternative is to not derive the session key material from $P_I$.
%
Doing so, however, deviates from the design of \mOptls{} (and similar protocols
from which the \mStat{}-based methods are derived), where the inclusion of
$P_I$ plays a crucial part in the security proof of resistance against
initiator ephemeral key compromise.
%
The third alternative is to include a fourth message from responder to initiator,
carrying a MAC based on a key derived from session key material including $P_I$.
%
Successful MAC verification guarantees
to the initiator that the responder injectively agrees on $P_I$.
%
We presented the options to IETF, and they decided to add a
fourth message as an option in the latest version of the
\mSpec{}~\cite{latest-ietf-lake-edhoc-05}.
%

Regardless of how this is handled, we verified that all methods
enjoy a common, but weaker, property: mutual implicit agreement
on all of $P_e, P_I$ and $P_R$, where applicable.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Conclusions and Future Work}}
\label{sec:conclusions}
\label{sec:newdrafts}
We formally modeled all four
methods of the \mEdhoc{} \mSpec{} using \mTamarin.
%
We formulated several important security properties and identified precise
adversary models in which we verified these.
%
The properties are shown in Table~\ref{tab:props}.
%
Mutual injective agreement covers the parameters $S_P$:
responder identity, roles, session key material (except for $P_I$ when
initiator uses the \mStat{} authentication
method), context identifiers \mCi{} and \mCr, and cipher suites \mSuites.
%
The responder in addition is ensured agreement on the initiators identity and
$P_I$, i.e., on the set $S_F$.
%
Implicit agreement covers all previously mentioned parameters for both peers.
%
Verification of all lemmas, including model validation lemmas, took 42 minutes
on an Intel Core i7-6500U 2.5GHz using two cores.
%
Mutual entity authentication, UKS- and KCI resistance can be inferred
from the verified properties.
%
\begin{table*}[h!]
        \centering
        \caption{Verified properties. $S_P$ contains
            roles, responder identity, session key material (excluding
            $P_I$), \mCi, \mCr, and \mSuites. $S_F$ is $S_{P}$,
            the initiator identity, and $P_I$.}
        \label{tab:props}
        \begin{tabular}{|l|c|c|c|c|}
                \hline
                & \mSigSig & \mSigStat & \mStatSig & \mStatStat \\
                \hline
                Injective agreement for I & $S_F$ & $S_F$ & $S_P$ & $S_P$\\
                Injective agreement for R & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                Implicit agreement for I & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                Implicit agreement for R & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                PFS for session key material & \cm & \cm & \cm & \cm\\
                \hline
        \end{tabular}
\end{table*}

Further, we identified a situation where initiators may establish an \mOscore{}
security context with a different party than the application using \mEdhoc{}
intended, and proposed a simple mitigation.
%
We discussed how the IETF may extract and better define security properties to
enable easier verification.

We verified each method in isolation, and leave as future work to verify whether
the methods are secure under composition.

%\subsection{Newer Versions of the Specification}
%\label{sec:newdrafts}
In this work, we have analyzed the \mEdhoc{} version as of July
2020~\cite{our-analysis-selander-lake-edhoc-00}.
%
There are newer versions, with the most recent version as
of February 2021~\cite{latest-ietf-lake-edhoc-05}.
%
However, the changes to the protocol over these versions are not
particularly significant for our analysis.
%

%-------------------------------------------------------------------------- ack
\section*{ACKNOWLEDGEMENTS}
This work was partially supported by
the Wallenberg AI, Autonomous Systems and Software Program (WASP) funded by
the Knut and Alice Wallenberg Foundation.
%
We are grateful to G\"oran Selander, John Mattsson and Francesca Palombini for
clarifications regarding the specification.
%

%-------------------------------------------------------------------------- bib
\bibliographystyle{apalike}
{\small
    \bibliography{refComp}
}
\end{document}
