% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}

\usepackage[scaled=0.8]{helvet}    % Less huge \textsf{functionName}
\usepackage[misc,geometry]{ifsym} % for letter symbol
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usetikzlibrary{trees,snakes,arrows}
\usetikzlibrary{shapes,chains}
\usetikzlibrary{positioning}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}
\usepackage[nospace]{cite}

\input{macros}

\title{Formal Analysis of EDHOC Key Establishment for Constrained IoT Devices}
\author{
        Karl Norrman and 
        Vaishnavi Sundararajan and
        Alessandro Bruni
}

\begin{document}
\maketitle
%
\begin{abstract}
Given how common IoT devices that use constrained resources are becoming today, the need of the hour is communication protocols which can operate securely under such limitations.
%
For a few years, the Internet Engineering Task Force (IETF) has been working to standardize \mEdhoc{}, an authenticated key establishment protocol for such constrained IoT devices.
%
The first version of \mEdhoc{} was proposed in 2016.
%
In 2018, Bruni et al~\cite{DBLP:conf/secsr/BruniJPS18} used the \mProverif{} tool~\cite{DBLP:conf/csfw/Blanchet01} to formally analyze an early version of \mEdhoc{}, which had only two key establishment methods.  
%
%By now, the protocol has been fleshed out much more, and has been augmented with multiple new key establishment methods.
By 2021, the protocol had been fleshed out much more, with multiple new key establishment methods, and this version was formally analyzed using the \mTamarin{} prover~\cite{DBLP:conf/cav/MeierSCB13} in~\cite{Norr21}.
%
Here, we build on this work, and use \mTamarin{} to formally analyze the key establishment methods in the current version of \mEdhoc{}, as well as discuss some ramifications of the choices made while designing the protocol.
\vnote{We need to see what more we can say here, about the new stuff we're potentially adding}
\end{abstract}
%
%-------------------------------------------------------------------------- sec
\section{\uppercase{Introduction}}
\label{sec:introduction}
\input{intro}

%-------------------------------------------------------------------------- sec
\section{\uppercase{The \mEdhoc{} Protocol}}
\label{sec:edhoc}
\input{protocol}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Formalization and Results}}
\label{sec:formalization}
\input{formalization}

%-------------------------------------------------------------------------- sec
\section{\uppercase{Denial of Service}}
\label{sec:dos}

% There is little about EDHOC specific DoS stuff; that is interesting in itself,
% and motivates this section
There is a wealth of information about DoS in general, and more specifically for
IoT.
%
However, there is little information regarding DoS aspects stemming
specifically from \mEdhoc{}.
%

% Other protocols have DoS considerations, but EDHOC delegates it to developer
In contrast to \mTls{} and IKEv2,
the \mEdhoc{} core specification does not include any specific measures for
countering Denial of Service (DoS) attacks.
%
Instead, that responsibility is delegated to the application, using
proprietary measures or extensions to \mEdhoc{}.
%

% The core is small and probably not vulnerable to anything unexpected
The \mEdhoc{} core specification has limited functionality, few negotiable
parameters and processing rules.
%
Hence, we argue in this section that its attack surface
is limited from a DoS perspective.
%

% However, It is difficult to define what EDHOC *is*; it s partially specified in many
% specs
However, \mEdhoc{} leaves much of the semantics of its messages undefined or
specified as extensions.
%
Examples of mechanisms with mostly undefined semantics include processing
rules and content of error messages and of the additional data that is
passed in each of the \mEdhoc{} messages.
%
Another example is that the core specification does not include a
message transport mechanism.
%
The transport for \mEdhoc's primary target, i.e., to key \mOscore{},
is \mCoap{}.
%
This is specified in~\cite{ietf-core-oscore-edhoc-03}, but still leaves
many design choices to the application.
%
Because of this, it is difficult to draw the line between what is considered as
\mEdhoc{} and what is an extension.
%

% Pros with undefined semantics: flexibilty; Cons: developers can shoot
% themselves in the foot
Undefined semantics allow the implementors much freedom
and flexibility to design applications.
%
On the down-side, the few recommendations given increase the risk of
applications being vulnerable to DoS via \mEdhoc{}, even
though the core \mEdhoc{} specification itself is arguably not particularly
weak in this respect.
%

\paragraph{DoS mitigation is left to developers.}
Section 8.7 of the \mEdhoc{} specification\footnote{draft-ietf-lake-edhoc-14}
explains the design philosophy w.r.t.
DoS in two paragraphs and gives two recommendations.
%
The first being that \mEdhoc{} relies on lower layers to mitigate DoS, and an
example of DoS countermeasures is given: checking return routeability when
receiving the first message.
%
The second being that an application may try to determine (in some way) that an
apparently valid message is in fact probably a forgery and should be ignored or
cause processing to stop.
%

No recommendation is given on how to minimize DoS effects stemming from use of
error messages, which can be used in an arbitrary way in \mEdhoc{}
(see Section~\ref{sec:errorHandling} below).
%
While there is some work on DDoS aspects of \mCoap{}, and much on IoT in
general, this does not capture the particular consequences originating with
\mEdhoc{}.
%
We now elaborate on some considerations application developers needs to take
into account.
%


\paragraph{Amplification and role asymmetry.}
For the same reasons as given in the IKEv2 DDoS analysis
by~\cite{rfc8019} the responder is more vulnerable than the
initiator.
%
The key similarity between IKEv2 and \mEdhoc{} here is that the initiator is
anonymous in the first message and that creating the first message is
computationally cheap and requires no storage.
%
No element in the first \mEdhoc{} message can be verified by the receiver as
being legitimate as long as the format is correct and elliptic curve points
lie on the proposed curve.
%
\mEdhoc{} leave it to the application and its
transport layer to resolve any issues.
%
In addition to the computational resources the responder spends, \mEdhoc{}
execution may require the responder to
obtain and verify certificate chains, and verify
certificate-revocation servers as a result of the spoofed initial message.
%
For example, the content of the \mADone{} information element may hint the
responder to take further actions.
%

The asymmetry between the adversary's effort and the responder's may hence be
significant.
%
Since \mEdhoc{} specifically targets constrained devices this asymmetry needs to
be considered even more carefully than for IKEv2~\cite{rfc8019}.
%

Depending on the use case, the first \mEdhoc{} message may be sent by either
party in a session.
%
For example, even though it may seem intuitive that an electronic
key-card initiates the connection towards lock, the first \mEdhoc{} message
could be included in the response from the lock.
%
This means the lock can postpone heavy verification actions until it has
authenticated the key card after receiving the third \mEdhoc{} message.
%
The draft IETF specification profiling \mEdhoc{} for use with
\mCoap{} and \mOscore{} ~\cite{ietf-core-oscore-edhoc-03},
however, defines the
\mCoap{} client to be the \mEdhoc{} initiator, and hence reduces the flexibility
to use that option.
%

\paragraph{Reflection Attacks.}
Reflection attacks are attacks where an adversary spoofs the source address of a
victim in a message and thereby tricks the responder to send a message to the
victim.
%
\mEdhoc{} leaves protection against this to the transport protocol and
application, and suggests using a return path reachability method similar to IKEv2.
%
We note that such reachability mechanisms can easily be used to make a responder
send reachability requests to arbitrary addressable targets.
%
Depending on the design of such reachability mechanisms, they may require that
unsolicited reachability requests are discarded, limiting the effects of
anonymous DoS attacks like these.
%

In situations where the responder does not need to perform additional
communications to verify certificates or similar, a reachability mechanism may
be more expensive in terms of time and storage compared to continue with the
protocol and keeping a half-open state for a period of time.
%
Doing so would also avoid creating secondary DoS effects on certificate storage
nodes or certificate revocation servers.
%
The latter may cause a systems-level issue if many distributed
\mEdhoc{} responders frequently requests such servers.
%
However, if round-trip times are large, and half-open states hence are kept
by the receiver for a long time, a reachability mechanism can trade
communication for storage.
\footnote{RFC8019 discuss some numbers as examples of tradeoffs. Should we set
up a simple model and derive an expression for trade-offs? Could be useful for
implementors to consider, but low academic value. This would capture also
amplification.}
%

%\mPoint{In a constrained device randomness may be easily depleted}
%Assume an adversary generate (deterministic) bogus message 1s and send these at
%a sufficiently high rate to the responder.
%%
%\mEdhoc{} specifically targets constrained devices, that presumably may not
%always have good randomness sources.
%%
%Is it possible to deplete or significantly reduce the entropy of the source and
%in this way be able to predict the responder's random input to other sessions
%(with other initiators)?
%%
%The LAKE WG have been talking about effects of poor randomness on signatures, so
%this should be an issue, no?
%%

\mPoint{\mEdhoc{} can deadlock if not used correctly}

An adversary may send forged error messages, and specifically reject proposed
ciphersuites.
%
The initiator is recommended to not try that ciphersuite with the responder
again in a new session for a while.
%
If the adversary rejects all options for a initiator this way, it can prevent
communication between the initiator and that responder until the cache is
cleared.
%
Potentially, an adversary could lock a party of a group out of communication all
together this way.
%
This needs to be considered by applications.
%

While we have not conducted a formal analysis of the fact, the structure of all
methods are so similar that it seems plausible that none of them would be
stronger against DDoS than the others.
%

Implementers are well advised to consult \cite{rfc8019}, which provides much
good general information about DoS for key establishment
protocols with the 3-message structure employed by \mEdhoc{}.
%
However, ultimately, a product-specific risk assessment is required to
determine appropriate DDoS mitigations.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Error handling}}
\label{sec:errorHandling}
\mPoint{Error handling is undefined except for algo negotiation} Section 6 of the \mEdhoc{} specification\cite{draft-ietf-lake-edhoc-15} states that error messages can be sent at any time and by any party.
%
At the current version of the standard \cite{draft-ietf-lake-edhoc-15}, there are three types of error messages: type 0 is used to represent success, type 1 represents a generic error message used for debugging purposes, where the actual message is an English string, and type 2 represents failure to negotiate a common ciphersuite. Type 2 messages carry a list of supported ciphersuites by the responder.
%
The contents and semantics of type 1 messages are dependent on the implementation.
%
Consequently, type 1 error messages provide a generic message passing mechanism, albeit one without a predefined semantics.

%\textbf{Q:} Is there any situation where it makes sense that the initiator sends an unsupported ciphersuite message instead of message 3?
%\textbf{Q:} In Section H: if no message correlation support by the transport layer, \mCi{} and \mCr{} should be used for correlation of messages to a session.

\subsection{Lack of connection identifiers in error messages}
Error messages do not include the optional connection identifiers \mCi{} or \mCr{} that are transmitted during the handshake.
This is potentially problematic for connection-less transport layers, where \mCi{} and \mCr{} may be used to correlate messages.

\subsection{Improper handling of error messages}
\mEdhoc{} provides the error message mechanism, but gives little to no guidance on how it should be used safely.
%
For example, assume that an application using \mEdhoc{} logs error messages on a finite log with log rotation.
%
If the log is used for anomaly detection or detection of sensitive events, then an adversary can simply inject error messages and fill the log until the sensitive event is overwritten.
%
If filling error messages in the log is less suspicious than the actual attack, this may be beneficial for the adversary.
%
Implementors should do proper log-separation and log management.

\subsection{Unspecified semantics for debugging messages}
Section 6.2 gives an example of sending a type 1 error message with the information string "Method not supported".
%
It's important to note that this message cannot be used to negotiate the connection method securely.
%
In fact -- differently from ciphersuite negotiation -- \mEdhoc{} does not include a mechanism to support negotiating the connection method, among the four available combinations of signature keys and static Diffie-Hellman keys.
%
The initiator selects the method on the first message, and the responder can reply with a type 1 error message along with the information string "Method not supported", but a standard compliant implementation cannot act upon this information string for negotiation purposes.
%
This is because the error message is not integrity protected and there is no secure mechanism to select a different authentication method that ensure that the preferred available authentication mechanism is always selected.
%
Because method negotiation can be viewed in the context of cryptographic agility, there is room for improvement.
%

Note: Section 5.1 says that if processing fails for some reason,
then "typically" an error message is sent processing is terminated and protocol
state is discarded. But: for algo negotiation (the only defined error
message), then state is not discarded.

Note: Section 5.2.2 says:
"The Initiator MUST NOT change the supported cipher suites and
the order of preference in SUITES\_I based on previous error messages."
But: what happens if order of preference changes for some other reason? Would it
be good it include a flag in msg1 to indicate to the responder that the
ciphersuite order depends on a previous run? This way, responder could react
differently if a new cipher suite has been added without breaking the "MUST NOT"
requirement. Need to think about this more.

Note: Section 5.3.3 says about receiver processing of message 2:
"If any processing step fails,
the Responder MUST send an EDHOC error message back, formatted as defined in
Section 6, and the session MUST be discontinued"
And Section 5.4.3 about the responder processing of message 3:
"If any processing step fails, the Responder MUST send an EDHOC error
message back, formatted as defined in Section 6, and the session MUST
be discontinued."
The same is said in Section 5.5.3 about the initiator's processing of message 4.

%-------------------------------------------------------------------------- sec
\section{\uppercase{Trusted Execution Environments}}
\label{sec:TEE}
The main purpose of Trusted Execution Environments (TEE) is to prevent an
adversary with physical access to a device from accessing the computational
circuits.
%
They come in various forms of differing complexity.
%
Some, like ARM Trust Zone and Intel SGX are general purpose execution
environments, which are flexibly programmable.
%
Other, like the Universal Subscriber Identity Modules (USIM) used for
authentication to 3GPP mobile networks, have application specific interfaces for
authentication and key agreement protocols etc.
%
A key aspect is how much of the application is placed in the TEE and how much is
outside.
%

For larger devices that include general purpose processors with Trust Zone or
SGX, entire \mEdhoc{} and \mOscore{} may reside inside the TEE.
%
For constrained IoT devices in the lower end of the scale, a TEE may have to be
implemented using a special-purpose integrated circuit.
%
In the latter case, it may be beneficial to follow a minimalistic approach, and
contain the long-term key and only
the operations that need access to it in the TEE for cost reasons.
%

It may at first appear more secure to implement as much as possible inside the
TEE, but there is a security trade-off: the more code inside the TEE,
the higher the risk of implementation errors in the security-critical code.
%
Because the security critical code runs in the area where the long-term keys
reside, an implementation error here risks leaking information of the key to the
adversary.
%
From this perspective, it may be beneficial to follow the minimalistic approach
even when having access to Trust Zone or SGX.
%

A slightly more secure division of functionality is to also keep the
session key inside
the TEE and extend the interface to accept messages and return the
(en/de)crypted counter part.
%
That is, the interface exposes \mAead{} functions in the interface.
%

%-------------------------------------------------------------------------- sub
\subsection{Practical Aspects and Use Case}
\label{sec:TEE:useCase}
Authentication of a specific IoT device assumes that this devices is the only
entity with access to the long-term key associated with the corresponding
identity.
%
Since IoT devices may be accessible to adversaries, e.g., an insider cloning a
key card, the long-term keys must be appropriately protected.
%
A state of the art approach is to use a Trusted Execution Environment (TEE),
which holds the key and provides an API for operations using the key.
%
This is the approach taken by the
Trust-Zone based \mMuEdhoc{}~\cite{DBLP:conf/codaspy/Hristozov0XFLS21}
implementation for example.
%
Typical operations include signatures using the long-term private key of a
party.
%

%-------------------------------------------------------------------------- sub
\subsection{System and Adversary Model Extensions Supporting TEE}
\label{sec:TEE:advModel}
%
We extend the adversary model of~\cite{Norr21} by allowing the adversary
access to a TEE interface on a party of their choosing before and after the
\mEdhoc{} session.
%
This corresponds to a so-called weak post-compromise security
(PCS)~\cite{DBLP:conf/csfw/Cohn-GordonCG16}.
%

We split the \mEdhoc{} functionality as follows.
%
The TEE contains the long-term key and allows the non-TEE parts of the
application to perform the operations on it via its interface.
%
More precisely, parties using the \mSig{} authentication method use a TEE with
an interface which accepts a message and returns the signature of that message
using the party's private long-term key.
%
Parties using the \mStat{} authentication method use a TEE with an interface
accepting $g^x$ and returning $g^x$ raised to the party's private long-term key.
\knote{It should accept any value. Adversary may not stick to elements of the
    form $g^x$. Or we explicitly state that the TEE checks that the received
input lies on the curve (but this may not be sufficient: are the curves cyclic
groups? Need to check).}
%
The non-TEE parts implement \mEdhoc{} using this interface.
%
This interface requires the least functionality from the TEE, reducing the TEE's
complexity and possibly cost of its implementation.
%
The functional split is suitable even for the situation where a
constrained device has implemented only the storage of the long-term key in a
special purpose circuit with minimal processing functionality.
%
Since \mEdhoc{} focuses on constrained IoT devices, it seems appropriate to
cater for this setting.
%

%-------------------------------------------------------------------------- sub
\subsection{Extended Formalism and Security Properties}
\label{sec:TEE:fmAndProps}
Formally, we model the TEE interface by adding two new rewrite rules:
%
\begin{small}
\begin{verbatim}
rule forge_SIG:
   [!LTK_SIG($A, ~ltk), In(xx)] --[TEE($A)]-> [Out(sign(xx, ~ltk))]

rule exp_STAT:
   [!LTK_STAT($A, ~ltk), In('g'^~xx)] --[TEE($A)]-> [Out(('g'^~xx)^~ltk)]
\end{verbatim}
\end{small}
%
These rules allow the adversary to obtain terms representing signatures on a
value of their choice to forge signatures (\verb|forge_SIG|), or to obtain terms
representing a curve point of their choice raised to the power of the
long-term key (\verb|exp_STAT|).
%

Because it is a trivial attack when the adversary access these rules with values
from the test session, we must disqualify those rule applications.
%
We do so by creating an action fact \verb|TEE($A)|, where \verb|$A| is the
identity corresponding to the private key used, and then augmenting the
properties with a condition that no such action fact exists from the start of
the protocol execution and its end.
%
Care must be taken when specifying the start and the end.
%
Specifically, ...
\knote{Need to check this. Should we not allow access to both parties keys
    before and after session? How could we otherwise claim KCI?
}
\knote{Need to check whether auth properties are correct. $\forall$ constructs
    should be like the $\exists$ constructs of PFS. Not only for symmetry, but
    they look incorrect now (should not be $\lor \forall \ldots$).
}


\paragraph{XOR expressiveness}
We did not manage to get Tamarin to terminate for all lemmas and all methods
with the added TEE extension.
%
When the responder uses the \mStat{} authentication method Tamarin did not
complete the in a reasonable time for the authentication lemmas.
%
To combat this, we simplified the modeling of XOR encryption of the second
message for these lemmas when the responder uses \mStat{} authentication.
%
More precisely, the second message contains the two values \verb|V| and
\verb|authV|, and we generally model the XOR encryption by xoring each of them
with their own key-stream terms.
%
For the problematic lemmas however, we resorted to xoring the entire tuple
\verb|<V, auth>| with a single key-stream term.
%
Given that no attacks were identified using our original modeling, this
simplification is intuitively not a severe restriction.
%
However, it is possible that we now miss attacks on these methods
combining properties of the two-term XOR encryption with TEE capabilities.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Discussion}}
\label{sec:discussion}
There are a few places where \mEdhoc{} can be improved,
which we found during this work and communicated to the authors.
%
We discuss them below.
%

%-------------------------------------------------------------------------- sub
\subsection{Unclear Intended Use}
\label{sec:unclearProtocolUse}
%
The \mEdhoc{} \mSpec{} lists several security goals, but they are
imprecise and difficult to interpret due to lack of context and intended usage
descriptions.
%
Without knowing how the protocol is to be used,
it is not clear whether the listed security goals are the most important ones
for constrained IoT devices.
%

The abstract goal of \mEdhoc{} is simple: establish an \mOscore{} security
context using few roundtrips and small messages.
%
From that, the design of \mEdhoc{} is mainly driven by what
can be achieved given the technical restrictions.
%
Focusing too much on what can be achieved within given restrictions, and paying
too little attention to the use cases where the
protocol is to be used and their specific goals, risks resulting in
sub-optimal trade-offs and design decisions.
%

\mEdhoc{} is intended to cover a variety of use cases, many of which are
difficult to predict today.
%
However, this does not
prevent collecting \emph{typical} use cases and user stories
to identify more specific security goals that will be important in most cases.
%

While constructing our model, we made up simple user stories to identify
security properties of interest.
%
Several of these revealed subtleties and undefined aspects of \mEdhoc{}.
%
We informed the \mEdhoc{} authors, who addressed these aspects in the
\mSpec{}.
%

\subsubsection{(Non-)Repudiation}
An access control solution for a nuclear power-plant may need to log who is
passing through a door, whereas it may be undesirable for, say, a coffee
machine to log a list of users along with their coffee preferences.
%
Via this simple thought experiment, we realized that the \mSpec{} did not
consider the concept of (non)-repudiation.
%
In response, the authors of the \mSpec{} added a paragraph discussing how
different methods relate to (non)-repudiation.

\subsubsection{Unintended Peer Authentication}
Section~3.2 of the \mSpec{} states that parties must be configured
with a policy restricting the set of peers they run \mEdhoc{} with.
%
However, the initiator is not required to verify that the \mIdcredr{} received
in the second message is the same as the one intended.
%
The following attack scenario is therefore possible.
%

Suppose someone has configured all devices in their home to be in the
allowed set of devices, but that one of the devices ($A$) is compromised.
%
If another device $B$, initiates a connection to a third device $C$, the
compromised device $A$ may interfere by responding in $C$'s place, blocking
the legitimate response from $C$.
%
Since $B$ does not verify that the identity indicated in the second message
matches the intended identity $C$, and device $A$ is part of the allowed set,
$B$ will complete and accept the \mEdhoc{} run with device $A$ instead of the
intended $C$.
%
The obvious solution is for the initiator to match \mIdcredr{} to the intended
identity indicated by the application, which we included in our model.
%
We have communicated this to the \mEdhoc{} authors and they are considering
how to resolve the issue.
%

%------------------------------------------------------------------------- sub
\subsection{Unclear Security Model}
We argue that the \mSpec{} gives too little information about what capabilities
an adversary is assumed to have, and that this leads to unclear design goals and
potentially sub-optimal design.
%

Even though \mEdhoc{} incorporates cryptographic cores from different academic
security protocols, its design does not take into account the adversary models
for which these protocols were designed.
%
For example, \mOptls{}, whose cryptographic core is essentially the same
as the \mStat{} authentication method, is designed to be secure in the CK
model~\cite{DBLP:conf/crypto/CanettiK02}.
%
The CK security model explicitly separates the secure storage of long-term
keys from storage of session state and ephemeral keys.
%
This is appropriate for modelling the use of secure modules.
%

The \mEdhoc{} authors indicated to us that it was
not necessary to consider compromised ephemeral keys separately from
compromised long-term keys.
%
The rationale is that \mSigma{} cannot protect against compromised ephemeral
keys~\cite{personalCommunication}.
%
That rationale is presumably based on the fact that the \mSigSig{} method is
closely modeled on the \mSigmaI{} variant of \mSigma{}, and that it would be
preferable to obtain a homogeneous security level among the \mEdhoc{}
methods.
%
That rationale is only true, however, if one restricts attention to session key
confidentiality of an ongoing session.
%
Secure modules provide value in other ways, for example, by allowing
constructions with Post-Compromise Security (PCS) guarantees.
%
We discussed this with the authors, and
the latest version of the \mSpec{}~\cite{latest-ietf-lake-edhoc-05} includes
recommendations on storage of long-term keys and operations on these inside a
secure module.
%

%-------------------------------------------------------------------------- sub
\subsection{Session Key Material}
\label{sec:sessionKeyMaterial}
\mEdhoc{} establishes session key material, from which session keys
can be derived using the \mEdhoc{}-Exporter.
%
The session key material is affected by \mGxy{}, and if a party uses the
\mStat{} authentication method, also by that party's secret static long-term key.
%
As shown in Section~\ref{sec:formalization}, mutual injective agreement cannot
be achieved for $P_I$.
%
If this property is not important for constrained IoT devices which cannot use
any of the other methods, then one can simply accept that the methods have
different authentication strengths.
%
Otherwise, this is a problem.
%

We identified three alternatives for resolving this.
%
One alternative is to include \mIdcredi{}, or its hash, in the first and
second messages.
%
This would, however, increase message sizes and prevent initiator identity
protection, which are grave concerns for \mEdhoc{}.
%
A second alternative is to not derive the session key material from $P_I$.
%
Doing so, however, deviates from the design of \mOptls{} (and similar protocols
from which the \mStat{}-based methods are derived), where the inclusion of
$P_I$ plays a crucial part in the security proof of resistance against
initiator ephemeral key compromise.
%
The third alternative is to include a fourth message from responder to initiator,
carrying a MAC based on a key derived from session key material including $P_I$.
%
Successful MAC verification guarantees
to the initiator that the responder injectively agrees on $P_I$.
%
We presented the options to IETF, and they decided to add a
fourth message as an option in the latest version of the
\mSpec{}~\cite{latest-ietf-lake-edhoc-05}.
%

Regardless of how this is handled, we verified that all methods
enjoy a common, but weaker, property: mutual implicit agreement
on all of $P_e, P_I$ and $P_R$, where applicable.
%

%-------------------------------------------------------------------------- sec
\section{\uppercase{Conclusions and Future Work}}
\label{sec:conclusions}
\label{sec:newdrafts}
We formally modeled all four
methods of the \mEdhoc{} \mSpec{} using \mTamarin.
%
We formulated several important security properties and identified precise
adversary models in which we verified these.
%
The properties are shown in Table~\ref{tab:props}.
%
Mutual injective agreement covers the parameters $S_P$:
responder identity, roles, session key material (except for $P_I$ when
initiator uses the \mStat{} authentication
method), context identifiers \mCi{} and \mCr, and cipher suites \mSuites.
%
The responder in addition is ensured agreement on the initiators identity and
$P_I$, i.e., on the set $S_F$.
%
Implicit agreement covers all previously mentioned parameters for both peers.
%
Verification of all lemmas, including model validation lemmas, took 42 minutes
on an Intel Core i7-6500U 2.5GHz using two cores.
%
Mutual entity authentication, UKS- and KCI resistance can be inferred
from the verified properties.
%
\begin{table*}[h!]
        \centering
        \caption{Verified properties. $S_P$ contains
            roles, responder identity, session key material (excluding
            $P_I$), \mCi, \mCr, and \mSuites. $S_F$ is $S_{P}$,
            the initiator identity, and $P_I$.}
        \label{tab:props}
        \begin{tabular}{|l|c|c|c|c|}
                \hline
                & \mSigSig & \mSigStat & \mStatSig & \mStatStat \\
                \hline
                Injective agreement for I & $S_F$ & $S_F$ & $S_P$ & $S_P$\\
                Injective agreement for R & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                Implicit agreement for I & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                Implicit agreement for R & $S_F$ & $S_F$ & $S_F$ & $S_F$\\
                PFS for session key material & \cm & \cm & \cm & \cm\\
                \hline
        \end{tabular}
\end{table*}
\knote{This should be extended with verification times and with TEE.
    It should also show that when responder uses \mStat{} and \mSig{}, a
    different XOR encryption is used.
}

Further, we identified a situation where initiators may establish an \mOscore{}
security context with a different party than the application using \mEdhoc{}
intended, and proposed a simple mitigation.
%
We discussed how the IETF may extract and better define security properties to
enable easier verification.

We verified each method in isolation, and leave as future work to verify whether
the methods are secure under composition.

%\subsection{Newer Versions of the Specification}
%\label{sec:newdrafts}
In this work, we have analyzed the \mEdhoc{} version as of July
2020~\cite{our-analysis-selander-lake-edhoc-00}.
%
There are newer versions, with the most recent version as
of February 2021~\cite{latest-ietf-lake-edhoc-05}.
%
However, the changes to the protocol over these versions are not
particularly significant for our analysis.
%

%-------------------------------------------------------------------------- ack
\section*{ACKNOWLEDGEMENTS}
This work was partially supported by
the Wallenberg AI, Autonomous Systems and Software Program (WASP) funded by
the Knut and Alice Wallenberg Foundation.
%
We are grateful to G\"oran Selander, John Mattsson and Francesca Palombini for
clarifications regarding the specification.
%

%-------------------------------------------------------------------------- bib
\bibliographystyle{apalike}
{\small
    \bibliography{refComp}
}
\end{document}
