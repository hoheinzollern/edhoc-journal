% !TEX root = paper.tex
In this section, we describe the various key establishment methods of the
\mEdhoc{} protocol.
%
Following~\cite{Norr21}, we refer to the two roles executing the protocol as
the initiator $I$ and the responder $R$.
%
We annotate values with $I$ and $R$ to make explicit which role they belong 
to.
%

%------------------------------------------------------------------------- sub
\subsection{Notation}
\label{sec:notation}
We denote by $\langle d_{t, \mathit{id}}, Q_{t, \mathit{id}}\rangle$
public-private key pairs, where $d$ is the private key, $Q$ is the public key,
$t \in \{e, s\}$ indicates whether the key is ephemeral or static,
and $\mathit{id}$ indicates the party to whom the key pair belongs.
%
When clear from context, we will often drop part (or all) of the subscripts.
%
Static key pairs (suitable for regular or challenge-response signatures)
are long-term authentication credentials, whereas ephemeral key pairs are 
those
which are generated afresh for each execution of the protocol.
%

Parties can authenticate using regular signatures or challenge-response
signatures.
%
In the former case, we say that they use the
\emph{signature based authentication method} (\mSig{}).
%
In the latter, we say, following the terminology in the \mSpec{},
that they use the \emph{static key authentication method} (\mStat{}).
%
We adopt the challenge-response terminology
from~\cite{DBLP:conf/crypto/Krawczyk05}.
%

\mEdhoc{} fundamentally use elliptic curves and associated Diffie-Hellman
operations.
%
Signatures using a party $A$'s keys are denoted by \mSign{A}$(\cdot)$, while
the verification thereof is denoted by \mVf{A}$(\cdot)$.
%
A Diffie-Hellman operation which combines a private key $d$ and a point $P$
on the elliptic curve is represented as $\mDH(d, P)$.
%
We will often overload notation to let $P$ stand for both the point on the
elliptic curve as well as the corresponding bitstring encoding.
%
%\mEdhoc{} relies on \mCose{}~\cite{rfc8152} for elliptic curve operations and
%transforming points into bitstrings, and we therefore abstract those as
%follows.
%
%Signatures and verification thereof using party $A$'s key pair are
%denoted \mSign{A}$(\cdot)$ and \mVf{A}$(\cdot)$ respectively.
%%
%The DH-primitive combining a private key $d$ and a point $P$ is denoted
%$\mDH(d,P)$.
%%
%We abuse notation and let these function symbols denote operations on both
%points and the corresponding bitstrings.
%

%------------------------------------------------------------------------- sub
\subsection{Overall Description}
\label{sec:description}
\mEdhoc{} is designed to establish a security context for \mOscore{}.
%
This context includes the session key material (we denote this by 
\mSessKey{}).
%
The abstract protocol as given in the \mSpec{}~\cite{} consists of three
messages, and is shown in Figure~\ref{fig:edhocFramework}~\cite{Norr21}.
%
The generalized abstract protocol is the same across methods,
and may transfer application data \mADone{}, \mADtwo{}, and \mADthree{} in
addition to establishing the context.
%
The authentication mechanisms and key derivation procedures differ between
methods.
%
We will describe the various aspects of the protocol now.
%
\begin{figure}[ht]
\centering
\tikzset{>=latex, every msg/.style={draw=thick}, every 
node/.style={fill=none,text=black}}
\begin{tikzpicture}
    \node (ini) at (0, 0) {Initiator};
    \draw [very thick] (0, -0.25) -- (0,-2.3);
    \draw [very thick] (5.75, -0.25) -- (5.75,-2.3);
    \node (res) at (5.75,0) {Responder};
    \msg{1em}{ini}{res}{\mMsgone: \mMethod, \mSuites, \mGx, \mCi, 
\mADone};
    \msg{3em}{res}{ini}{\mMsgtwo: \mCi, \mGy, \mCr, \{\mIdcredr, \mAuthr, 
\mADtwo\}};
    \msg{5em}{ini}{res}{\mMsgthree: \mCr, \{\mIdcredi, \mAuthi, \mADthree\}};
    \draw [line width=1mm] (-0.75,-2.3) -- (0.75,-2.3);
    \draw [line width=1mm] (5.75-0.75,-2.3) -- (5.75+0.75,-2.3);
    \node (padding) at (0,-2.5) {};
    \end{tikzpicture}
    \caption{Structure of \mEdhoc{}: $\{t\}$ means $t$ is encrypted and integrity
protected.~\cite{Norr21}}
\label{fig:edhocFramework}
\end{figure}
%
Of the three messages, the first two, among other things, serve to establish a
common authentication method \mMethod{}, and a ciphersuite \mSuites{}.
%
In \mMethod{}, the party playing the initiator role proposes which
authentication methods the two parties shall use, and an ordered list
of choices for the ciphersuite.
%
As mentioned earlier, the authentication methods may differ for the two roles,
yielding four possible
combinations: \mSigSig{}, \mSigStat{}, \mStatSig{}, and \mStatStat{},
where the first authentication method in each combination is used by the
initiator role, and the second by the responder role.
\footnote{As in the \mSpec{}, we will from now on overload
notation and refer to the combinations of authentication methods as methods 
as
well.}
%
The party executing the responder role may choose to reject the method or
ciphersuite chosen by the initiator by sending an error message.
%
This results in abandoning this session and renegotiating, as the initiator
goes down their list of choices for ciphersuites, and picks the next option for
a next execution of the protocol.
%
Our analysis does not cover such renegotiation which requires maintaining 
state
between executions to remember the rejected ciphersuites.
%
However, we will discuss the ramifications of such a renegotiation procedure
and the error messages later, in Section~\ref{sec:errorHandling}.
%

In addition to negotiating the ciphersuite, the first two messages are
also instrumental for the exchange of public ephemeral keys \mGx{} and 
\mGy{},
and connection identifiers \mCi{} and \mCr{}, for the initiator and responder
roles respectively.
%
The \mSpec{} states that the connection identifiers serve only to route 
messages
to the correct party executing \mEdhoc{}, but also claims that they may be
used in turn by protocols (like \mOscore{}) using the security context
established by \mEdhoc{}.
%
While the \mSpec{} does not require any explicit security guarantees to be
satisfied by these connection identifiers, it does, however, require that the
identifiers be unique, i.e., in any session, $\mCi{} \neq \mCr{}$, and that the
parties involved in the session can verify this uniqueness.
%
More precisely, the \mSpec{} states that \mOscore{} should be able to use these
identifiers to retrieve any particular security context.
%
In this work, as in~\cite{Norr21}, we verify that the parties agree on the
values of \mCi{} and \mCr{}.
%
The second and third messages also serve to identify and authenticate each
party to the other.
%
These messages contain long-term key identifiers (\mIdcredi{} and 
\mIdcredr{}).
%
Additionally, the messages contain authenticating information
(\mAuthi{} and \mAuthr{}), which lets each
party know that the other party does indeed control the long-term key
associated with these identifiers.
%
The authentication information is different for each authentication method.
%
Consider the following example scenario.
%
The initiator $I$ chooses the method $\mSigStat{}$ and sends this via
$\mMethod{}$ to the responder $R$.
%
$R$ now has an option to either reject this choice of method, or to provide an
identifier \mIdcredr{} for a key pair which can be used with 
challenge-response
signatures 
as well as authenticating information \mAuthr{}, as dictated by
the static key authentication method \mStat{}.
%
$I$ will then respond with an identifier \mIdcredi{} corresponding to a key
pair, which is suitable for regular signatures, and provide authentication
\mAuthi{} as appropriate for the signature-based method \mSig{}.

%-------------------------------------------------------------------------- sub
\subsection{Key Schedule}
\label{sec:keysched}
As mentioned above, the second and third messages of \mEdhoc{} contain
authenticating information.
%
This information is either a signature or a message authentication code (MAC),
as we will describe in more detail in Section~\ref{sec:edhocauth}.
%
The keys for these are generated by using a key schedule which takes at least
one DH key \mGxy{} as basic input, as shown in Figure~\ref{fig:kdfdiagram},
and is intrinsic to the functioning of \mEdhoc{}.
%
\begin{figure}[!h]
\scalebox{.785}{
\input{kdfdiagram.tex}
}
\caption{Key schedule: $P_e, P_I, P_R$ are the DH keys, \mPRKtwo, 
\mPRKthree, \mPRKfour{} are the intermediate key material, and 
\mKtwoe,\mKtwom, 
\mKthreeae, \mKthreem{} are the encryption keys for \mAead{} or 
\mXor{}. Dashed boxes are conditionals.~\cite{Norr21}}
\label{fig:kdfdiagram}
\end{figure}
%

To derive keys, \mEdhoc{} uses two functions from the \mHkdf{}
interface~\cite{rfc5869}, \mHkdfExtract{} and \mHkdfExpand{}.
%
Both functions take as argument two values -- a salt, and an input.
%
For \mHkdfExtract{}, the input is a DH key, while for \mHkdfExpand{},
it is intermediate key material.
%

As mentioned earlier, the fundamental building block for the key schedule is
the ephemeral DH key \mGxy{}, which is computed in two different ways by
$I$ (as $\mDH(\mX, \mGy)$) and $R$ (as $\mDH(\mY, \mGx)$).
%
This key gives rise to intermediate keys \mPRKtwo{}, \mPRKthree{} and
\mPRKfour{}, which can be derived as part of protocol execution.
%
Each intermediate key gives rise to encryption and integrity keys
(\mKtwoe, \mKtwom{}, \mKthreeae, and \mKthreem)
for a particular message in the protocol.
%

In order to generate the final keys, the two \mHkdf{} algorithms use various
values for salt.
%
\mPRKtwo{} is generated by the \mHkdfExtract{} algorithm while using the 
empty
string as the salt.
%
\mPRKthree{} and \mPRKfour{} are separately generated if $R$ or $I$ uses the
\mStat{} method, using the corresponding DH key as input and the previous
intermediate key as salt.
%
The key $P_{R}$ is used if the responder uses the \mStat{} authentication 
method.
%
$P_{R}$ is the key computed as $\mDH(\mX,\ \mGr{}) = \mDH(\mPriv{R},\ 
\mGx)$.
%
Similarly, the key $P_{I}$ is used if the initiator uses \mStat{}, and is 
computed as $\mDH(\mY,\ \mGi{}) = \mDH(\mPriv{I},\ \mGy)$.
%

These intermediate keys are fed into \mHkdfExpand{}, as shown in 
Figure~\ref{fig:kdfdiagram}.
%
\mHkdfExpand{} here uses as salt a value $\textit{th}$, which is a running 
hash of the information transmitted thus far as part of the protocol.
%
$\textit{th}_{i}$ denotes the hash corresponding to the $i^{\rm{th}}$ message.
%

At the end of a successful run of the protocol, the session key material is
established as \mSessKey{}, which we define as a set of various keys.
%
This set always includes \mGxy{}, and if the initiator (resp. the responder) uses 
the \mStat{} authentication method, then it also includes $P_{I}$ (resp. 
$P_{R}$).
%
We 
%discuss which material should be included in \mSessKey{} in more detail 
in
the formal model in Section~\ref{sec:formalization} and the consequences of
various choices in Section~\ref{sec:sessionKeyMaterial}.
%
Once \mSessKey{} has been established, an \mHkdf{}-based key exporter 
named
\mEdhoc-Exporter extracts the keys required by the security protocol.
%

%-------------------------------------------------------------------------- sub
\subsection{About Authentication in \mEdhoc{}}
\label{sec:edhocauth}
We now describe how the authentication information is constructed, 
depending on which method is used.
%
For both \mStat{} and \mSig{}, the following information is used to compute
\mAuthr{}: \mIdcredr{}, \mCredr{}, a transcript hash of all the communicated
information thus far in the protocol, and \mADtwo{}, if included.
%
\mAuthi{} uses the same pieces of information, but corresponding to the
initiator role.
%
A MAC is obtained by feeding this material as additional data and the empty
string as input to the Authenticated Encryption with Additional Data (AEAD)
encryption algorithm as indicated in the established ciphersuite \mSuites{}.
%
The encryption key for the AEAD algorithm is constructed, for both roles,
using the ephemeral key material \mGx{}, \mGy{}, \mX{}, and \mY{}.
%
The initiator computes $\mDH(\mX, \mGy)$ while the responder computes
$\mDH(\mY, \mGx)$, and DH operations give rise to the same key under both
these computations.
%

When $I$ uses the \mSig{} authentication method, \mAuthi{} is $I$'s signature
over the MAC along with the data covered by the MAC.
%
However, when $I$ uses the \mStat{} method, \mAuthi{} is just the MAC, with
one difference: the MAC key is derived using both the ephemeral key material
\mGxy{} as well as the long-term key for the initiator
$\langle\mPriv{I},\ \mPub{I}\rangle$.
%
This is similar to the 1-RTT semi-static pattern in \mOptls{} which computes the
MAC key \textsf{sfk} for the message
\textsf{sfin}~\cite{DBLP:conf/eurosp/KrawczykW16}.
%
The same procedures works for $R$ as well (with the values corresponding to 
$R$).
%
The abstract calculation for the authentication information values is as shown
in Table~\ref{tab:authvalues}~\cite{Norr21}.
%
We use $\mathit{MAC}_{I}$ (resp. $\mathit{MAC}_{R}$) to denote a MAC 
which uses
an encryption key constructed using
$\langle\mPriv{R},\ \mPub{R}\rangle$ and $\langle\mX,\ \mGx\rangle$
(resp. using $\langle\mPriv{I},\ \mPub{I}\rangle$ and $\langle\mY,\ 
\mGy\rangle$).
%
\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|}
        \hline
        \mMethod & \mAuthi & \mAuthr\\
        \hline
        \mSigSig{} & $\mSign{I}(\cdot)$ & $\mSign{R}(\cdot)$ \\
        \mSigStat{} & $\mSign{I}(\cdot)$ & $\textit{MAC}_R(\cdot)$\\
        \mStatSig{} & $\textit{MAC}_I(\cdot)$ & $\mSign{R}(\cdot)$\\
        \mStatStat{} & $\textit{MAC}_I(\cdot)$ & $\textit{MAC}_R(\cdot)$\\
        \hline
\end{tabular}
\caption{The outer functions for each method \mMethod{}~\cite{Norr21}}
\label{tab:authvalues}
\end{table}
%

In addition to this, the second and third messages have
provisions for transferring application messages which are encrypted and
integrity protected, as can be seen in~\ref{fig:edhocFramework}.
%
The second message is encrypted by performing a bit-wise \mXor{} between
the plaintext and the output of the key derivation function \mHkdf{}, as
in Section~\ref{sec:keysched}.
%
For the third message, encryption and integrity protection is assured by the
\mAead{} algorithm which is part of the established ciphersuite \mSuites{}.
%

In Figure~\ref{fig:edhocsigstat} we show an example of protocol execution 
under
the \mSigStat{} method.
%
The figure describes in detail the various message patterns, operations and
key derivations used to construct these messages.
%\vnote{Do we still have the other method diagrams that we wrote out for the 
%original paper but did not include?}
%\knote{I don't think we have space for that.}
%
\begin{figure}[ht]
\centering
\scalebox{.7}{
\tikzset{>=latex, every msg/.style={draw=thick}, every 
node/.style={fill=none,text=black}}
\begin{tikzpicture}
    \node (ini) at (0, 0) {Initiator};
    \draw [very thick] (0, -0.5) -- (0,-14.8);
    \draw [very thick] (9, -0.5) -- (9,-14.8);
    \node[below=0.5em of ini,fill=white] {$
    \begin{array}{c}
        \text{Knows}\ \langle\mPriv{I},\ \mPub{I}\rangle,\ \mIdcredi,\ \mIdcredr,\ 
\mADone,\ \mADthree
    \end{array}
    $};
    \node (res) at (9,0) {Responder};
    \node[below=0.5em of res,fill=white] {$
    \begin{array}{c}
        \text{Knows}\ \langle\mPriv{R},\ \mPub{R}\rangle, \ \mIdcredr,\ \mADtwo
    \end{array}$};
    \action{3.7em}{ini}{Generates $\mMethod,\ \mSuites,\ \mCi,\ \langle\mX{},\ 
\mGx\rangle$};
    \msg{7em}{ini}{res}{\mMsgone: \mMethod, \mSuites, \mGx, \mCi, 
\mADone};
    \action{8em}{res}{$
      \begin{array}{c}
          \text{Generates } \mCr,\ \langle\mY{},\ \mGy\rangle\\
          \ \ P_e = \mDH(\mY,\ \mGx{})\\
          \ \ P_R = \mDH(\mPriv{R},\ \mGx{})\\
        \mTHtwo = \mHash(\mMsgone, \langle \mCi, \mGy, \mCr \rangle)\\
        \mPRKtwo = \mHkdfExtract(\textrm{``\phantom{}''}, P_e) \\
        \mPRKthree = \mHkdfExtract(\mPRKtwo, P_R) \\
        \mKtwom = \mHkdfExpand(\mPRKthree, \mTHtwo) \\
        \mMactwo = \mAead(\mKtwom; \langle \mIdcredr, \mTHtwo, \mCredr, 
\mADtwo \rangle; \textrm{``\phantom{}''}) \\
        \mKtwoe = \mHkdfExpand(\mPRKtwo, \mTHtwo)
      \end{array}$};
    \msg{24em}{res}{ini}{\mMsgtwo: \mCi, \mGy, \mCr, $\overbrace{\mKtwoe\ 
\mXor\ \langle \mIdcredr, \mMactwo, \mADtwo \rangle}^{\mCipher}$};
    \action{25em}{ini}{$
      \begin{array}{c}
        %\mTHtwo = \mHash(\mMsgone, \langle \mCi, \mGy, \mCr \rangle) \
        \ P_e = \mDH(\mX,\ \mGy{})\\
        \mPRKtwo = \mHkdfExtract(\textrm{``\phantom{}''}, P_e) \\
        %\mKtwoe = \mHkdfExpand(\mPRKtwo,\mTHtwo)\\
        %\mGrx = \mCredr^{x} \\
        \ \ P_R = \mDH(\mX,\ \mPub{R})\\
        \mPRKfour = \mPRKthree = \mHkdfExtract(\mPRKtwo, P_R) \\
        %\mKtwom = \mHkdfExpand(\mPRKthree, \mTHtwo) \\
        \mKthreeae = \mHkdfExpand(\mPRKthree, \mTHtwo) \\
        \mTHthree = \mHash(\mTHtwo, \mCipher, \mCr)\\
        \mKthreem = \mHkdfExpand(\mPRKfour, \mTHthree) \\
        \mMacthree = \mAead(\mKthreem; \langle \mIdcredi, \mTHthree, 
\mCredi, \mADthree \rangle; \textrm{``\phantom{}''}) \\
        \mSigthree = \mSign{I}(\langle \langle \mIdcredi, \mTHthree, \mCredi, 
\mADthree \rangle, \mMacthree \rangle)
      \end{array}$};
    \msg{38.5em}{ini}{res}{$\mMsgthree: \mCr, \mAead(\mKthreeae; 
\mTHthree; \langle \mIdcredi, \mSigthree, \mADthree \rangle$)};
    \action{40em}{res}{$
    \begin{array}{c}
        \mTHthree = \mHash(\mTHtwo, \mCipher, \mCr)\\
        \mKthreem = \mHkdfExpand(\mPRKthree, \mTHthree) \\
        \mKthreeae = \mHkdfExpand(\mPRKthree, \mTHthree)
    \end{array}$};
    \draw [line width=1mm] (-2,-14.8) -- (2,-14.8);
    \draw [line width=1mm] (7,-14.8) -- (11,-14.8);
    \end{tikzpicture}
}
    \caption{The \mSigStat{} method for \mEdhoc{}. $\langle\cdot\rangle$ 
denotes a tuple, and the hash function \mHash{} is as established in the 
ciphersuite \mSuites{}.~\cite{Norr21}}
\label{fig:edhocsigstat}
\end{figure}

%------------------------------------------------------------------------- sec
\section{Implementation Aspects and Key Protection}
\label{sec:TEE}
Authentication of a specific IoT device assumes that this devices is the only
entity with access to the long-term key associated with the corresponding
identity.
%
Since IoT devices may be accessible to adversaries, e.g., an insider cloning a
key card, the long-term keys must be appropriately protected.
%
A state of the art approach is to use a Trusted Execution Environment (TEE),
which holds the key and provides an API for operations using the key.
%
This is the approach taken by the
Trust-Zone based \mMuEdhoc{}~\cite{DBLP:conf/codaspy/Hristozov0XFLS21}
implementation for example.
%
Typical operations include signatures using the long-term private key of a
party.
%

TEEs come in various forms of differing complexity.
%
Some, like ARM Trust Zone and Intel SGX are general purpose execution
environments, which are flexibly programmable.
%
Other, like the Universal Subscriber Identity Modules (USIM) used for
authentication to 3GPP mobile networks, have application specific interfaces 
for
authentication and key agreement protocols etc.
%
A key aspect is how much of the application is placed in the TEE and how 
much is
outside.
%

For larger devices that include general purpose processors with Trust Zone or
SGX, entire \mEdhoc{} and \mOscore{} may reside inside the TEE.
%
For constrained IoT devices in the lower end of the scale, a TEE may have to be
implemented using a special-purpose integrated circuit.
%
In the latter case, it may be beneficial to follow a minimalistic approach, and
contain the long-term key and only
the operations that need access to it in the TEE for cost reasons.
%

It may at first appear more secure to implement as much as possible inside the
TEE, but there is a security trade-off: the more code inside the TEE,
the higher the risk of implementation errors in the security-critical code.
%
Because the security critical code runs in the area where the long-term keys
reside, an implementation error here risks leaking information of the key to 
the
adversary.
%
From this perspective, it may be beneficial to follow the minimalistic approach
even when having access to Trust Zone or SGX.
%

A slightly more secure division of functionality is to also keep the
session key inside
the TEE and extend the interface to accept messages and return the
(en/de)crypted counter part.
%
That is, the interface exposes \mAead{} functions in the interface.
%

